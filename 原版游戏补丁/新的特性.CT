<?xml version="1.0" encoding="utf-8"?>
<CheatTable CheatEngineTableVersion="45">
  <CheatEntries>
    <CheatEntry>
      <ID>0</ID>
      <Description>"植物死亡消梯问题"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(PlantsOnLawn,16)
label(returnhere)
label(originalcode)
label(exit)

newmem:
pushad
//ebp是植物指针
push [ebp+1C]
push [ebp+28]
mov ebx,PlantsOnLawn
mov edx,[ebp+4]
call 40D2A0
//通过+8获取南瓜指针
mov eax,[PlantsOnLawn+4]
test eax,eax
je __467A31
cmp [ebp+24],1E
jne __467A38
popad

originalcode:
mov esi,eax
call 0044D000

exit:
jmp returnhere

__467A31:
popad
jmp originalcode

__467A38:
popad
jmp 467A38

467A31:
jmp newmem
nop 2
returnhere:

[DISABLE]
dealloc(newmem)
dealloc(PlantsOnLawn)
467A31:
db 8B F0 E8 C8 55 FE FF
//mov esi,eax
//call 0044D000
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>1</ID>
      <Description>"三叶草吹飞双脚离地"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//eax是僵尸状态
cmp eax,34//海豚跳起
je 46660D
cmp eax,3A//潜水跳起
je 46660D
cmp eax,47//小鬼飞出
je 46660D

originalcode:
cmp eax,49
je 00466608

exit:
jmp returnhere

4665FE:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)
4665FE:
db 83 F8 49 74 05
//cmp eax,49
//je 00466608
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>3</ID>
      <Description>"去除资资源上限"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]

430A25:
nop 0A

430A7A:
nop 7


[DISABLE]

430A25:
db C7 80 60 55 00 00 06 27 00 00
//mov [eax+00005560],00002706

430A7A:
db C7 40 28 9F 86 01 00
//mov [eax+28],0001869F
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>4</ID>
      <Description>"SquishAllIZombiesInSquare"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//居然没用上...留着吧
alloc(SquishAllZombiesInSquare,128)
registersymbol(SquishAllZombiesInSquare)

//自己设计函数,函数功能是杀死某格内与调用僵尸阵营不同的所有僵尸
//ZombieAttackType参数不再有实际意义
//Zombie::SquishAllZombiesInSquare(int theGridY, int theGridX, edi = Zombie* this)
SquishAllZombiesInSquare:

//开辟缓冲区
sub esp,8

//易变寄存器问题(为了方便,直接全部保存)
pushad

//遍历僵尸
lea esi,[esp+24]
mov edx,[edi]
call 41C8F0
test al,al
je break

__loop:
//精准堆栈,获取theGridY-&gt;ecx
mov ecx,[esp+30]
mov esi,[esp+24]
//esi是遍历到的僵尸指针
//+1C表示僵尸行数
cmp [esi+1C],ecx
jne continue
//设法获取僵尸所在的列数
mov eax,[esi+8]
mov ecx,[edi+4]
call 41C4C0
//eax就是僵尸的列数
cmp eax,[esp+30]
jne continue
//比较阵营
mov al,byte ptr [esi+B8]
cmp al,byte ptr [edi+B8]
je continue
//满足条件,弄死它!
mov ecx,esi
call 5302F0

continue:
lea esi,[esp+24]
mov edx,[edi]
call 41C8F0
test al,al
jne __loop

break:
popad
add esp,8
ret 8


[DISABLE]
dealloc(SquishAllZombiesInSquare)
unregistersymbol(SquishAllZombiesInSquare)
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>6</ID>
      <Description>"冰车碾压被魅惑的僵尸"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//碾压当前格子内被魅惑的僵尸
//ebx已经是僵尸指针了
push ebx
call 52E840
//结果eax就是目标僵尸指针
test eax,eax
je originalcode
//令目标僵尸直接死亡
mov esi,eax
mov eax,9
//学习计组是很重要的
//伤害数值是一个int类型,是有符号数,所以必须考虑补码问题
push 7FFFFFFF
call 5317C0
//音效
mov esi,15
mov eax,[ebp+8]
mov eax,[eax]
call 453630

originalcode:
lea edi,[esp+10]
call 00532140

exit:
jmp returnhere

52EDBF:
jmp newmem
nop 4
returnhere:

[DISABLE]
dealloc(newmem)
52EDBF:
db 8D 7C 24 10 E8 78 33 00 00
//lea edi,[esp+10]
//call 00532140
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>7</ID>
      <Description>"巨人砸被魅惑的僵尸-01"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//判断是否有可以攻击的对方僵尸目标,如果有,那就举锤
//ebx是僵尸指针
push ebx
call 52E840
test eax,eax
je originalcode
//设置一下巨人目前正在攻击的僵尸指针
pushad
push [eax+158]
push ebx
call SetTargetZombieID
popad
//真正跳转
jmp 5272AC

originalcode:
mov ecx,[ebx]
call 004538F0

exit:
jmp returnhere


52724E:
jmp newmem
nop 2
returnhere:

[DISABLE]
dealloc(newmem)
52724E:
db 8B 0B E8 9B C6 F2 FF
//mov ecx,[ebx]
//call 004538F0
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>8</ID>
      <Description>"TargetZombieID"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
//这是我的天才级别的发明!
//"给僵尸新增属性"这件事情具有巨大阻力,但是我有替代方案
//设立一个"属性表",通过僵尸ID来查表
//这不代表在任何情况下都可以这么做,这样做的前提是僵尸有一个唯一标识身份的ID
//准确的讲应该是通过栈位寻址

//1024*4
alloc(TargetZombieID,4096)
registersymbol(TargetZombieID)
alloc(GetTargetZombieID,256)
registersymbol(GetTargetZombieID)
//为了调试方便,不再单独分配设置目标僵尸ID的内存空间
label(SetTargetZombieID)
registersymbol(SetTargetZombieID)

//提供对外的访问接口
//ZombieID Zombie::GetTargetZombieID(Zombie* this)
//影响的寄存器:ebx,ecx,eax
GetTargetZombieID:
//僵尸指针
mov ebx,[esp+4]
//僵尸编号低16位(栈位)
//看来还不能用byte ptr...
mov ecx,[ebx+158]
and ecx,FFFF
mov eax,[TargetZombieID+ecx*4]
ret 4

//void Zombie::SetTargetZombieID(ZombieID theId,Zombie* this)
//影响到寄存器:eax,ebx,ecx,edx
SetTargetZombieID:
//需要设置为的ID
mov edx,[esp+8]
//僵尸指针
mov ebx,[esp+4]
//this的ID
mov ecx,[ebx+158]
//获取低16位即栈位
and ecx,FFFF
//偏移寻址,设置TargetZombieID
mov [TargetZombieID+ecx*4],edx
ret 8



[DISABLE]
dealloc(TargetZombieID)
unregistersymbol(TargetZombieID)
dealloc(GetTargetZombieID)
unregistersymbol(GetTargetZombieID)
unregistersymbol(SetTargetZombieID)
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>9</ID>
      <Description>"巨人砸被魅惑的僵尸-02"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(temp,4)
label(returnhere)
label(originalcode)
label(exit)

//ebx-&gt;巨人僵尸指针
newmem:
pushad
//获取目标僵尸ID
push ebx
call GetTargetZombieID
mov [temp],eax
popad
pushad
//根据ID获取目标僵尸
mov ecx,[temp]
mov edx,[ebx+4]
call 41C7F0
//如果目标僵尸存在,则令其死亡
test eax,eax
je originalcode
//巨人暂时不可能被魅惑,所以放心大胆让目标僵尸去世就行了
mov esi,eax//传参先后顺序有要求
mov eax,9
push 7FFFFFFF
call 5317C0
popad

originalcode:
mov ecx,[ebx]
mov eax,[ecx+000007F8]

exit:
jmp returnhere

526DB0:
jmp newmem
nop 3
returnhere:

[DISABLE]
dealloc(newmem)
dealloc(temp)
526DB0:
db 8B 0B 8B 81 F8 07 00 00
//mov ecx,[ebx]
//mov eax,[ecx+000007F8]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>10</ID>
      <Description>"TargetZombieID-修复栈位bug"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//edi是僵尸指针
//清除栈位相关的数据
pushad
push 0
push edi
call SetTargetZombieID
popad

originalcode:
mov ecx,[edi+00000110]

exit:
jmp returnhere

41BBB1:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
41BBB1:
db 8B 8F 10 01 00 00
//mov ecx,[edi+00000110]
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>11</ID>
      <Description>"矿工爬梯子修复"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//向左走的矿工不应该无视梯子
cmp dword ptr [ebp+28],26
je exit

originalcode:
cmp dword ptr [ebp+24],11
je 0052FBEA

exit:
jmp returnhere

52FBA5:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
52FBA5:
db 83 7D 24 11 74 3F
//cmp dword ptr [ebp+24],11
//je 0052FBEA
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>12</ID>
      <Description>"大蒜包扎术-01"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp ebx,24
je 41090D

originalcode:
cmp ebx,17
jne 41091C

exit:
jmp returnhere

410908:
jmp newmem
returnhere:



[DISABLE]
dealloc(newmem)
410908:
db 83 FB 17 75 0F
//cmp ebx,17
//jne 0041091C
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>13</ID>
      <Description>"大蒜包扎术-02"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp esi,24
je 40E404

originalcode:
cmp esi,17
jne 0040E511

exit:
jmp returnhere

40E3FB:
jmp newmem
nop 4
returnhere:

 
[DISABLE]
dealloc(newmem)
40E3FB:
db 83 FE 17 0F 85 0D 01 00 00
//cmp esi,17
//jne 0040E511
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>14</ID>
      <Description>"一路出巨人"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
40DC03:
nop 0A

 
 
[DISABLE]
40DC03:
cmp ecx,17
je 0040DC37
cmp ecx,20
je 0040DC37

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>15</ID>
      <Description>"废除丢车保护"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
40DD32:
fld1
nop 4

40DD4B:
fld1
nop 4
 
 
[DISABLE]
40DD32:
fld dword ptr [67949C]

40DD4B:
fld dword ptr [6793C0]

</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>16</ID>
      <Description>"关于紫卡的推荐选卡问题-01"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//新增对于紫卡问题的判断
cmp esi,28
je NotRecommended
cmp esi,29
je NotRecommended
cmp esi,2A
je NotRecommended
cmp esi,2B
je NotRecommended
cmp esi,2C
je NotRecommended
cmp esi,2D
je NotRecommended
cmp esi,2E
je NotRecommended
cmp esi,2F
je NotRecommended
jmp originalcode

NotRecommended:
or edi,100

originalcode:
mov eax,edi
pop edi
ret 
int 3 

exit:
jmp returnhere

41CD61:
jmp newmem
returnhere:

 
[DISABLE]
dealloc(newmem)
41CD61:
db 8B C7 5F C3 CC
//mov eax,edi
//pop edi
//ret 
//int 3 
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>17</ID>
      <Description>"关于紫卡的推荐选卡问题-02"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(UpgradedTable,32)
alloc(newmem,2048)
alloc(temp,4)
label(returnhere)
label(originalcode)
label(exit)
registersymbol(UpgradedTable)

UpgradedTable:
//双发
db 07 00 00 00
//向日葵
db 01 00 00 00
//大喷
db 0A 00 00 00
//莲叶
db 10 00 00 00
//西瓜
db 27 00 00 00
//磁力
db 1F 00 00 00
//地刺
db 15 00 00 00
//玉米
db 22 00 00 00

//此代码不存在问题
newmem:
//判断一下是不是紫卡选卡存在问题
test ebx,100
je originalcode
pushad
//查看已选植物中是否已经有该项紫卡的底座
mov ecx,ebp
sub esi,28
mov edi,[UpgradedTable+esi*4]
call 486CE0
mov [temp],eax
popad
mov eax,[temp]
test al,al
je originalcode
//将ebx从右往左第8位设置为0
and ebx,-101
//写回
mov eax,ebx

originalcode:
test bl,01
je 0048460F

exit:
jmp returnhere

4845F3:
jmp newmem
returnhere:

[DISABLE]
dealloc(newmem)
unregistersymbol(UpgradedTable)
4845F3:
db F6 C3 01 74 17
//test bl,01
//je 0048460F
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>18</ID>
      <Description>"关于紫卡的推荐选卡问题-03"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(temp,4)
label(returnhere)
label(originalcode)
label(exit)

//基本思路:把经过"紫卡修正"之后的结果保存到eax
newmem:
//先行保存结果
mov [esp+18],eax
test eax,100
je originalcode
pushad
mov ecx,[esp+34]
//使用一下紫卡底座表
sub esi,28
mov edi,[UpgradedTable+esi*4]
call 486CE0
mov [temp],eax
popad
//重新取得eax
mov eax,[temp]
test al,al
//再次获取刚刚的flags
mov eax,[esp+18]
je originalcode
and eax,-101

originalcode:
//夜间植物问题
test al,01
mov [esp+18],eax

exit:
jmp returnhere

4849FC:
jmp newmem
nop
returnhere:

 
[DISABLE]
dealloc(newmem)
4849FC:
db A8 01 89 44 24 18
//test al,01
//mov [esp+18],eax
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>19</ID>
      <Description>"关于紫卡的推荐选卡问题-04"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(CardVibrating,96)
label(returnhere)
label(originalcode)
label(exit)
registersymbol(CardVibrating)

newmem:
//eax是SeedType
mov byte ptr [CardVibrating+eax],01

originalcode:
mov edx,eax
shl edx,04

exit:
jmp returnhere

485ECF:
jmp newmem
returnhere:




 
 
[DISABLE]
dealloc(newmem)
dealloc(CardVibrating)
unregistersymbol(CardVibrating)

485ECF:
db 8B D0 C1 E2 04
//mov edx,eax
//shl edx,04
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>20</ID>
      <Description>"关于紫卡的推荐选卡问题-05"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//继续修复紫卡抖动问题
//无需考虑初始化问题:如果一张卡被选上它的数组元素会自动清零
pushad
mov eax,[eax+20]
mov byte ptr [CardVibrating+eax],0
popad


originalcode:
mov edx,[eax+18]
mov [eax],edx

exit:
jmp returnhere

484FDA:
jmp newmem
returnhere:

 
 
[DISABLE]
dealloc(newmem)
484FDA:
db 8B 50 18 89 10
//mov edx,[eax+18]
//mov [eax],edx
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>21</ID>
      <Description>"关于紫卡的推荐选卡问题-06"</Description>
      <LastState/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//是这样的:尽管我分析不出来具体代码
//但是如果对应的卡牌处于抖动状态,就应该无条件返回true
//edi是植物类型1
cmp byte ptr [CardVibrating+edi],0
jne return_true


originalcode:
push esi
xor esi,esi
add ecx,000000C4

exit:
jmp returnhere

return_true:
mov eax,1
ret

486CE0:
jmp newmem
nop 4
returnhere:


 
 
[DISABLE]
dealloc(newmem)
486CE0:
db 56 33 F6 81 C1 C4 00 00 00
//push esi
//xor esi,esi
//add ecx,000000C4
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>23</ID>
      <Description>"修复矿工隔花盆排雷"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(PlantsOnLawn,16)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//修复矿工地下排雷bug
//僵尸指针ebp,植物指针esi
pushad
//判断植物所在位置是否有垫花盆
push [esi+1C]
push [esi+28]
mov ebx,PlantsOnLawn
mov edx,[esi+4]
call 40D2A0
mov eax,[PlantsOnLawn]
test eax,eax
popad
//若垫花盆则不进行处理
jne 52E578

originalcode:
cmp edx,04
jne 0052E578

exit:
jmp returnhere

52E569:
jmp newmem
returnhere:


 
 
[DISABLE]
dealloc(newmem)
dealloc(PlantsOnLawn)
52E569:
db 83 FA 04 75 0A
//cmp edx,04
//jne 0052E578
</AssemblerScript>
    </CheatEntry>
    <CheatEntry>
      <ID>24</ID>
      <Description>"修复矿工隔花盆被炸"</Description>
      <LastState Activated="1"/>
      <VariableType>Auto Assembler Script</VariableType>
      <AssemblerScript>[ENABLE]
alloc(newmem,2048)
alloc(PlantsOnLawn,16)
label(returnhere)
label(originalcode)
label(exit)

newmem:
//加入特判,判断是否是"土豆雷隔着花盆发现了地底下的僵尸"
//发现的僵尸是处于地底下的矿工吗?
cmp [eax+28],20
jne originalcode
//edi是植物指针
pushad
push [edi+1C]
push [edi+28]
mov ebx,PlantsOnLawn
mov edx,[edi+4]
call 40D2A0
mov eax,[PlantsOnLawn]
test eax,eax
popad
//如果发现存在底盘植物,那就不要调用DoSpecial
jne 46001F

originalcode:
push edi
call 004666A0

exit:
jmp returnhere

460013:
jmp newmem
nop
returnhere:

 
 
[DISABLE]
dealloc(newmem)
460013:
db 57 E8 87 66 00 00
//push edi
//call 004666A0
</AssemblerScript>
    </CheatEntry>
  </CheatEntries>
  <UserdefinedSymbols/>
  <DisassemblerComments>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAD0</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAD7</Address>
      <Comment>mov ebp,-1
用于对序列大小进行自减
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BADA</Address>
      <Comment>废话代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAE0</Address>
      <Comment>if (aItem == nullptr)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAE4</Address>
      <Comment>mPlants.mBlock
aItem = &amp;mBlock[0];
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAEC</Address>
      <Comment>aItem++;
由于aItem是指针,所以++不等于数值上加一
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAF1</Address>
      <Comment>mPlants.mMaxUsedCount
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAF7</Address>
      <Comment>mBlock
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BAFD</Address>
      <Comment>ecx是相当于mBlock的数组偏移
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB05</Address>
      <Comment>while ((unsigned int)aItem &lt; (unsigned int)aLast)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB09</Address>
      <Comment>废话
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB15</Address>
      <Comment>判断[eax+148]的高16位
为什么偏移是148?因为每个数据项包含两个部分,Plant和id
sizeof(Plant)=148,通过+148刚好可以获取到mID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB22</Address>
      <Comment>while循环的再次比较
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB28</Address>
      <Comment>植物是否已经死亡?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB2E</Address>
      <Comment>若没有死亡则跳转到比较下一个
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB30</Address>
      <Comment>获取ID(局部变量anId)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB37</Address>
      <Comment>mov ecx,mPlants.mFreeListHead
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB3D</Address>
      <Comment>mFreeListHead = anId;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB43</Address>
      <Comment>aItem-&gt;mID = 之前的mFreeListHead;
通过ecx保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1BB49</Address>
      <Comment>mSize--
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1DE20</Address>
      <Comment>ecx是id,判断id是否为空
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1DE27</Address>
      <Comment>通过movzx起到保留低位的作用
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1DE35</Address>
      <Comment>eax就是&amp;aBlock-&gt;mItem
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1DE39</Address>
      <Comment>aBlock-&gt;mID == theId
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+1DE45</Address>
      <Comment>如果edx被搞成了全零,那么返回nullptr
如果被搞成了全1,那么eax不变
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+60069</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+6006C</Address>
      <Comment>获取植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+6006F</Address>
      <Comment>if (mState != PlantState::STATE_TANGLEKELP_GRABBING)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+60197</Address>
      <Comment>if (mStateCountdown == 50)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+6019D</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+601A0</Address>
      <Comment>目标僵尸编号
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"PlantsVsZombies.exe"+601A6</Address>
      <Comment>僵尸序列在界面中的偏移
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B50</Address>
      <Comment>开始分析构造函数
Board::Board(ecx = LawnApp* theApp, Board* this)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B6A</Address>
      <Comment>精准堆栈,获取this指针(Board)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B72</Address>
      <Comment>Widget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B73</Address>
      <Comment>获取theApp实参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B79</Address>
      <Comment>父类Widget构造函数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B82</Address>
      <Comment>虚函数地址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7B93</Address>
      <Comment>又是虚函数?重复设置一次?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7BA2</Address>
      <Comment>从此一直到[ebp+134]全是初始化内存

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7BC0</Address>
      <Comment>僵尸序列-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7BEA</Address>
      <Comment>植物序列-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7C14</Address>
      <Comment>子弹序列-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7C3E</Address>
      <Comment>mCoins-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7C68</Address>
      <Comment>mLawnMowers-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7C92</Address>
      <Comment>mCoins-&gt;mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CA3</Address>
      <Comment>mApp = theApp;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CA9</Address>
      <Comment>/*(sizeof(Zombie)+sizeof(int))*1024*/
unsigned int _Size
接下来全是DataArray&lt;?&gt;::DataArrayInitialize的函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CB4</Address>
      <Comment>分配内存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CB9</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CC1</Address>
      <Comment>/*(sizeof(Plant)+sizeof(int))*1024*/
unsigned int _Size
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CC6</Address>
      <Comment>mBlock
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CCC</Address>
      <Comment>mMaxSize
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CD2</Address>
      <Comment>/*%s*/
mName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CDC</Address>
      <Comment>mNextKey
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CE6</Address>
      <Comment>分配内存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7CEB</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+7D04</Address>
      <Comment>unsigned int _Size
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+D4F3</Address>
      <Comment>单纯为了保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+D4F4</Address>
      <Comment>int theGridY

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+D4F5</Address>
      <Comment>int theGridX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB20</Address>
      <Comment>易变寄存器
即使一个人不打算做改版也不打算做修改器而只是想打游戏
那也应该研究一下这里的代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB21</Address>
      <Comment>获取int* theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB25</Address>
      <Comment>theRow &gt;= MAX_GRID_SIZE_Y
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB2A</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB30</Address>
      <Comment>mApp-&gt;mGameMode
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB36</Address>
      <Comment>mApp-&gt;mGameMode == GameMode::GAMEMODE_CHALLENGE_RESODDED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB39</Address>
      <Comment>将[esp+8]位置用于存储游戏模式
这个位置原本是为了存储形参的,但是被占用了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB44</Address>
      <Comment>mPlantRow[theRow] == PlantRowType::PLANTROW_DIRT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB4E</Address>
      <Comment>return false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB54</Address>
      <Comment>再次比较mApp-&gt;mGameMode == GameMode::GAMEMODE_CHALLENGE_RESODDED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB59</Address>
      <Comment>再次比较mPlantRow[theRow] == PlantRowType::PLANTROW_DIRT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB63</Address>
      <Comment>mCurrentWave &lt; 5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB6C</Address>
      <Comment>获取僵尸类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB70</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB71</Address>
      <Comment>mPlantRow[theRow]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB78</Address>
      <Comment>mPlantRow[theRow] == PlantRowType::PLANTROW_POOL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB7B</Address>
      <Comment>if (mPlantRow[theRow] == PlantRowType::PLANTROW_POOL...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB7D</Address>
      <Comment>ZombieType theZombieType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB7F</Address>
      <Comment>Zombie::ZombieTypeCanGoInPool(theZombieType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB84</Address>
      <Comment>if (...!Zombie::ZombieTypeCanGoInPool(theZombieType))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB88</Address>
      <Comment>mPlantRow[theRow] == PlantRowType::PLANTROW_HIGH_GROUND
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB8D</Address>
      <Comment>theZombieType != ZombieType::ZOMBIE_ZAMBONI
冰车不能走上高地

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB92</Address>
      <Comment>theZombieType != ZombieType::ZOMBIE_BOBSLED
同上
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB98</Address>
      <Comment>return false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DB9E</Address>
      <Comment>mApp-&gt;mGameMode == GameMode::GAMEMODE_CHALLENGE_LAST_STAND
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBA2</Address>
      <Comment>int aCurrentWave = mCurrentWave;
aCurrentWave保存至ebx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBAA</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBAC</Address>
      <Comment>GetNumWavesPerSurvivalStage()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBB1</Address>
      <Comment>mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBB7</Address>
      <Comment>mChallenge-&gt;mSurvivalStage * GetNumWavesPerSurvivalStage()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBBB</Address>
      <Comment>获取游戏模式

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBBF</Address>
      <Comment>僵尸类型theZombieType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBC3</Address>
      <Comment>aCurrentWave += mChallenge-&gt;mSurvivalStage * GetNumWavesPerSurvivalStage()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBC5</Address>
      <Comment>mPlantRow[theRow] == PlantRowType::PLANTROW_POOL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBCA</Address>
      <Comment>aCurrentWave &lt; 5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBCF</Address>
      <Comment>theZombieType == ZombieType::ZOMBIE_SNORKEL
判断僵尸是否为水路独有
潜水
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBD4</Address>
      <Comment>theZombieType == ZombieType::ZOMBIE_DOLPHIN_RIDER
海豚
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBD9</Address>
      <Comment>mPlantRow[theRow] == PlantRowType::PLANTROW_POOL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBDE</Address>
      <Comment>原理同上
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBE8</Address>
      <Comment>theZombieType == ZOMBIE_BOBSLED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBED</Address>
      <Comment>!mIceTimer[theRow]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBF5</Address>
      <Comment>雪橇队只能在冰道出现
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBF7</Address>
      <Comment>theRow == 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBFB</Address>
      <Comment>代码混淆,使得判断逻辑变得复杂
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DBFE</Address>
      <Comment>mGameMode &lt;= GameMode::GAMEMODE_SURVIVAL_ENDLESS_STAGE_5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC03</Address>
      <Comment>theZombieType == ZombieType::ZOMBIE_GARGANTUAR
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC06</Address>
      <Comment>"自古一路无巨人"原理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC08</Address>
      <Comment>theZombieType == ZombieType::ZOMBIE_REDEYE_GARGANTUAR
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC0D</Address>
      <Comment>theZombieType != ZombieType::ZOMBIE_DANCER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC12</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC14</Address>
      <Comment>StageHasPool()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC1D</Address>
      <Comment>eax=ebp-1
即eax=theRow-1
eax = int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC20</Address>
      <Comment>ecx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC22</Address>
      <Comment>RowCanHaveZombies(theRow - 1)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC2B</Address>
      <Comment>eax = int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC2E</Address>
      <Comment>RowCanHaveZombies(theRow + 1)
ecx = Board* this无需额外传递
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC50</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC52</Address>
      <Comment>获取this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC55</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC57</Address>
      <Comment>GetRake()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC5E</Address>
      <Comment>if (GetRake())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC62</Address>
      <Comment>aRake-&gt;mGridItemState == GridItemState::GRIDITEM_STATE_RAKE_ATTRACTING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC68</Address>
      <Comment>获取僵尸类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC6C</Address>
      <Comment>aRake-&gt;mGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC6F</Address>
      <Comment>ZombieType theZombieType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC70</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC71</Address>
      <Comment>esi = Board* this
无需专门传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC7A</Address>
      <Comment>分支体
/*mRowPickingArray*/
ecx = TodSmoothArray* theArray
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC80</Address>
      <Comment>/*aRake-&gt;mGridY*/
edx = int thePickIndex

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC82</Address>
      <Comment>aRake-&gt;mGridItemState = GridItemState::GRIDITEM_STATE_RAKE_WAITING;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC8E</Address>
      <Comment>return aRake-&gt;mGridY;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DC99</Address>
      <Comment>int aRow = 0
edi就是theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCA0</Address>
      <Comment>ZombieType theZombieType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCA1</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCA2</Address>
      <Comment>RowCanHaveZombieType(aRow, theZombieType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCA7</Address>
      <Comment>if (!RowCanHaveZombieType(aRow, theZombieType))

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCB0</Address>
      <Comment>mRowPickingArray[aRow].mWeight = 0;
658=654+4
这是一个浮点属性

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCBC</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCC2</Address>
      <Comment>mApp-&gt;mGameMode

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCC8</Address>
      <Comment>else if (mApp-&gt;mGameMode == GameMode::GAMEMODE_CHALLENGE_PORTAL_COMBAT)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCCD</Address>
      <Comment>ebx = Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCD5</Address>
      <Comment>edi = int theGridY无需专门传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCDF</Address>
      <Comment>mRowPickingArray[aRow].mWeight = mChallenge-&gt;PortalCombatRowSpawnWeight(aRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCED</Address>
      <Comment>mApp-&gt;mGameMode == GameMode::GAMEMODE_CHALLENGE_INVISIGHOUL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCF2</Address>
      <Comment>mCurrentWave &lt;= 3
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DCFB</Address>
      <Comment>aRow == 5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD00</Address>
      <Comment>mRowPickingArray[aRow].mWeight = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD08</Address>
      <Comment>mCurrentWave
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD10</Address>
      <Comment>mWaveRowGotLawnMowered[aRow]
mCurrentWave - mWaveRowGotLawnMowered[aRow]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD17</Address>
      <Comment>无需额外传参:ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD1C</Address>
      <Comment>mApp-&gt;IsContinuousChallenge()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD20</Address>
      <Comment>mNumWaves
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD26</Address>
      <Comment>mNumWaves - 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD29</Address>
      <Comment>mCurrentWave == mNumWaves - 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD2D</Address>
      <Comment>if (aWavesMowered &lt;= 1)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD3A</Address>
      <Comment>sizeof(TodSmoothArray)=16
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD3D</Address>
      <Comment>mRowPickingArray[aRow].mWeight = 0.01f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD46</Address>
      <Comment>else if (aWavesMowered &lt;= 2)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD56</Address>
      <Comment>mRowPickingArray[aRow].mWeight = 0.5f;
原理同上
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD66</Address>
      <Comment>mRowPickingArray[aRow].mWeight = 1.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD6D</Address>
      <Comment>aRow++
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD70</Address>
      <Comment>for循环的下一轮判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD79</Address>
      <Comment>edi = TodSmoothArray* theArray
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+DD81</Address>
      <Comment>TodPickFromSmoothArray(mRowPickingArray, MAX_GRID_SIZE_Y)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+FD4B</Address>
      <Comment>if (theClickCount &lt; 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+FDC0</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+FDC6</Address>
      <Comment>mApp-&gt;IsIZombieLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+FDE3</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+FDE5</Address>
      <Comment>GetSeedTypeInCursor()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D40</Address>
      <Comment>ecx传递this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D5C</Address>
      <Comment>%s
此参数被传入一个废弃的函数,无意义
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D65</Address>
      <Comment>获取this(界面)指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D67</Address>
      <Comment>这是一个废弃的函数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D87</Address>
      <Comment>mCutScene
eax = CutScene* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+15D8D</Address>
      <Comment>mCutScene-&gt;Update();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAD0</Address>
      <Comment>分析ProcessDeleteQueue有着重大意义
易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAD2</Address>
      <Comment>ebx之后会一直等于零
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAD4</Address>
      <Comment>Plant* aPlant = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAD7</Address>
      <Comment>在游戏对象序列大小--时会用到ebp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAE0</Address>
      <Comment>eax对应aItem
if (aItem == nullptr)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAE4</Address>
      <Comment>aItem = &amp;mBlock[0];
DataArray::IterateNext被展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAEC</Address>
      <Comment>aItem++;
aItem是指针类型,所以++不等于加一
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAF1</Address>
      <Comment>mPlants.mMaxUsedCount
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAF7</Address>
      <Comment>mPlants.mBlock
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BAFD</Address>
      <Comment>sizeof(Plant)+sizeof(int)=14C
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB03</Address>
      <Comment>DataArray&lt;T&gt;::DataArrayItem* aLast = &amp;mBlock[mMaxUsedCount];
ecx对应aLast
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB05</Address>
      <Comment>while ((unsigned int)aItem &lt; (unsigned int)aLast)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB10</Address>
      <Comment>用于接下来的按位与操作
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB15</Address>
      <Comment>aItem-&gt;mID &amp; DATA_ARRAY_KEY_MASK
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB1B</Address>
      <Comment>if (!(aItem-&gt;mID &amp; DATA_ARRAY_KEY_MASK))

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB1D</Address>
      <Comment>aItem++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB22</Address>
      <Comment>下一轮循环的比较
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB26</Address>
      <Comment>遍历失败
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB28</Address>
      <Comment>if (aPlant-&gt;mDead)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB30</Address>
      <Comment>DataArrayFree的展开
通过movzx来实现了位运算
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB37</Address>
      <Comment>之前的mFreeListHead

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB3D</Address>
      <Comment>unsigned int anId = aItem-&gt;mID &amp; DATA_ARRAY_INDEX_MASK;
mFreeListHead = anId;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB43</Address>
      <Comment>僵尸元素mID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB49</Address>
      <Comment>mSize--;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB51</Address>
      <Comment>while循环结束了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB56</Address>
      <Comment>Zombie* aZombie = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB58</Address>
      <Comment>if (aItem == nullptr)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB5C</Address>
      <Comment>aItem = &amp;mBlock[0];
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB64</Address>
      <Comment>aItem++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB6A</Address>
      <Comment>mMaxUsedCount
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB7C</Address>
      <Comment>DataArray&lt;T&gt;::DataArrayItem* aLast = &amp;mBlock[mMaxUsedCount];
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB7E</Address>
      <Comment>while ((unsigned int)aItem &lt; (unsigned int)aLast)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB82</Address>
      <Comment>if (!(aItem-&gt;mID &amp; DATA_ARRAY_KEY_MASK))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB8A</Address>
      <Comment>aItem++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB90</Address>
      <Comment>再次while判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BB9E</Address>
      <Comment>如果刚刚的判断edi==ebx就会跳转到这里来
这就说明僵尸序列已经被遍历完成了
子弹序列

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBA9</Address>
      <Comment>if (aZombie-&gt;mDead)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBB1</Address>
      <Comment>Zombie析构函数被展开了
AttachmentDie被展开了

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBD0</Address>
      <Comment>动画附件的大小
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBD6</Address>
      <Comment>edx=mAttachments
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBF9</Address>
      <Comment>Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1BBFA</Address>
      <Comment>StopZombieSound();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4C0</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4C1</Address>
      <Comment>使用ebx来保存theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4C3</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4C9</Address>
      <Comment>mApp-&gt;mGameMode==GameMode::GAMEMODE_CHALLENGE_ZEN_GARDEN

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4D2</Address>
      <Comment>mBackground
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4D8</Address>
      <Comment>mBackground == BackgroundType::BACKGROUND_MUSHROOM_GARDEN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4DD</Address>
      <Comment>mBackground == BackgroundType::BACKGROUND_ZOMBIQUARIUM
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4E2</Address>
      <Comment>mBackground == BackgroundType::BACKGROUND_GREENHOUSE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4E7</Address>
      <Comment>mApp-&gt;mZenGarden
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4ED</Address>
      <Comment>mApp-&gt;mZenGarden-&gt;PixelToGridX(theX, theY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4F2</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4F4</Address>
      <Comment>if (theX &lt; LAWN_XMIN)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4F9</Address>
      <Comment>return -1;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1C4FE</Address>
      <Comment>theX-40
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC60</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC63</Address>
      <Comment>小喷菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC68</Address>
      <Comment>海蘑菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC6D</Address>
      <Comment>阳光菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC72</Address>
      <Comment>大喷菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC77</Address>
      <Comment>魅惑菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC7C</Address>
      <Comment>核弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC81</Address>
      <Comment>寒冰菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC86</Address>
      <Comment>磁力菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC8B</Address>
      <Comment>胆小菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC90</Address>
      <Comment>忧郁菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC95</Address>
      <Comment>获取场景
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CC9B</Address>
      <Comment>黑夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCA0</Address>
      <Comment>雾夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCA5</Address>
      <Comment>夜晚屋顶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCAA</Address>
      <Comment>蘑菇园
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCAF</Address>
      <Comment>不知道是什么场地
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCB4</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_NOCTURNAL, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCB9</Address>
      <Comment>咖啡豆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCC4</Address>
      <Comment>黑夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCC9</Address>
      <Comment>雾夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCCE</Address>
      <Comment>黑夜屋顶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCD3</Address>
      <Comment>蘑菇园
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCD8</Address>
      <Comment>???
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCDD</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_AT_NIGHT, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCE5</Address>
      <Comment>墓碑吞噬者
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCEA</Address>
      <Comment>edx = Board* this
隐含传参
StageHasGraveStones()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCF3</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_NEEDS_GRAVES, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCF8</Address>
      <Comment>灯
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CCFD</Address>
      <Comment>edx = Board* this
StageHasFog()
隐含传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD0B</Address>
      <Comment>花盆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD16</Address>
      <Comment>屋顶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD1B</Address>
      <Comment>屋顶黑夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD20</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_NEEDS_ROOF, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD29</Address>
      <Comment>屋顶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD2E</Address>
      <Comment>屋顶黑夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD33</Address>
      <Comment>地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD38</Address>
      <Comment>钢地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD3D</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_ON_ROOF, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD40</Address>
      <Comment>泳池
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD45</Address>
      <Comment>雾夜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD4A</Address>
      <Comment>莲叶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD4F</Address>
      <Comment>水草
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD54</Address>
      <Comment>海蘑菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD59</Address>
      <Comment>猫尾草
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1CD5E</Address>
      <Comment>SetBit(aNotRec, NotRecommend::NOT_RECOMMENDED_NEEDS_POOL, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309D0</Address>
      <Comment>易变寄存器
eax是物品指针
(比较冷门的函数)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309D1</Address>
      <Comment>esi = Coin* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309D3</Address>
      <Comment>Die();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309D8</Address>
      <Comment>获取物品类型保存到eax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309DB</Address>
      <Comment>mType == CoinType::COIN_SUN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309E0</Address>
      <Comment>mType == CoinType::COIN_SMALLSUN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309E5</Address>
      <Comment>mType == CoinType::COIN_LARGESUN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309EA</Address>
      <Comment>正常阳光

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309EF</Address>
      <Comment>正常阳光价值25
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309F6</Address>
      <Comment>小阳光
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+309FB</Address>
      <Comment>又是莫名其妙的代码混淆
mov ecx,F
小阳光价值15
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A02</Address>
      <Comment>大阳光
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A05</Address>
      <Comment>又是巧妙的编译优化
如果刚好是大阳光那么ecx仍然等于零
如果不是那么ecx等于1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A08</Address>
      <Comment>如果是大阳光0-1=FFFFFFFF
如果不是就会变成00000000
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A0B</Address>
      <Comment>如果是大阳光那么ecx=(十进制)50,反之ecx=0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A0E</Address>
      <Comment>共用代码
有大量的函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A11</Address>
      <Comment>阳光+=ecx
ecx是阳光价值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A17</Address>
      <Comment>重新获取新的阳光数目
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A1D</Address>
      <Comment>如果阳光越界则需要调整
阳光上限
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A25</Address>
      <Comment>调整为9990
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A31</Address>
      <Comment>theType == CoinType::COIN_SILVER
银币
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A36</Address>
      <Comment>theType == CoinType::COIN_GOLD
金币
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A3B</Address>
      <Comment>theType == CoinType::COIN_DIAMOND
钻石
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A40</Address>
      <Comment>银币
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A45</Address>
      <Comment>edx用于临时保存钱币价值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A4C</Address>
      <Comment>金币
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A51</Address>
      <Comment>mov edx,5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A58</Address>
      <Comment>钻石
又是巧妙地编译优化
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A61</Address>
      <Comment>和刚刚的逻辑一模一样
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A64</Address>
      <Comment>钱币的共用代码段
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A66</Address>
      <Comment>获取存档信息
(因为金币是需要存档的,而阳光不需要)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A6C</Address>
      <Comment>金钱数+=金钱价值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A6F</Address>
      <Comment>金钱上限处理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A87</Address>
      <Comment>金钱为零(第一次收集金钱)的特殊处理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A94</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A97</Address>
      <Comment>mBoard-&gt;mDiamondsCollected++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30A9D</Address>
      <Comment>mType == CoinType::COIN_DIAMOND
是否为钻石?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30AA1</Address>
      <Comment>不是则跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30AA3</Address>
      <Comment>和植物以及僵尸一样
+4位置为mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30AA9</Address>
      <Comment>获取mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+30AAC</Address>
      <Comment>收取钻石数++
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2E2</Address>
      <Comment>辣椒
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2E5</Address>
      <Comment>现在先只分析辣椒的专用代码
因为这个函数实在是太大了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2E7</Address>
      <Comment>根据经验,ebx是植物指针
eax = Plant* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2E9</Address>
      <Comment>IsInPlay()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2EE</Address>
      <Comment>if (IsInPlay())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2F0</Address>
      <Comment>辣椒如果在非战斗关卡,就应该安安静静的呆着
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2F6</Address>
      <Comment>("anim_explode")
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2FB</Address>
      <Comment>ecx = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E2FD</Address>
      <Comment>mDoSpecialCountdown = 100;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E304</Address>
      <Comment>aBodyReanim-&gt;SetFramesForLayer("anim_explode");
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E309</Address>
      <Comment>aBodyReanim-&gt;mLoopType = ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E310</Address>
      <Comment>eax = LawnApp* this
很好!函数没有被展开!
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E312</Address>
      <Comment>esi = FoleyType theFoleyType
/*FoleyType::FOLEY_REVERSE_EXPLOSION*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5E317</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_REVERSE_EXPLOSION);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5FE25</Address>
      <Comment>植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5FE40</Address>
      <Comment>获取植物状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5FE48</Address>
      <Comment>if (mState == PlantState::STATE_NOTREADY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5FF18</Address>
      <Comment>else if (mState == PlantState::STATE_POTATO_RISING)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+5FFFE</Address>
      <Comment>else if (mState == PlantState::STATE_POTATO_ARMED)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60006</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60007</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60008</Address>
      <Comment>ecx = PlantWeapon thePlantWeapon
/*PlantWeapon::WEAPON_PRIMARY*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6000A</Address>
      <Comment>FindTargetZombie(mRow, PlantWeapon::WEAPON_PRIMARY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6000F</Address>
      <Comment>if (FindTargetZombie(mRow, PlantWeapon::WEAPON_PRIMARY))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60013</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60014</Address>
      <Comment>DoSpecial();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6001F</Address>
      <Comment>/*mLightReanimID*/
ecx = ReanimationID theReanimationID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60025</Address>
      <Comment>/*mApp*/
eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60027</Address>
      <Comment>mApp-&gt;ReanimationTryToGet(mLightReanimID);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6002C</Address>
      <Comment>Reanimation* aLightReanim = mApp-&gt;ReanimationTryToGet(mLightReanimID);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6002E</Address>
      <Comment>if (aLightReanim)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60032</Address>
      <Comment>/*TodCurves::CURVE_LINEAR*/
TodCurves theCurve

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60034</Address>
      <Comment>int thePositionEnd
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60036</Address>
      <Comment>int thePositionStart
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60038</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60039</Address>
      <Comment>/*DistanceToClosestZombie()*/
eax = int theTimeAge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6003E</Address>
      <Comment>ecx = int theTimeEnd
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60043</Address>
      <Comment>edx = int theTimeStart
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60048</Address>
      <Comment>TodAnimateCurve(200, 50, DistanceToClosestZombie(), 10, 3, TodCurves::CURVE_LINEAR)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6004D</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+60050</Address>
      <Comment>aLightReanim-&gt;mFrameCount = TodAnimateCurve(200, 50, DistanceToClosestZombie(), 10, 3, TodCurves::CURVE_LINEAR);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B80</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B82</Address>
      <Comment>精准堆栈,植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B86</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B89</Address>
      <Comment>if (mSeedType == SeedType::SEED_SQUASH)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B8C</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B90</Address>
      <Comment>植物状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B93</Address>
      <Comment>mState == PlantState::STATE_SQUASH_RISING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62B9C</Address>
      <Comment>mState == PlantState::STATE_SQUASH_FALLING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BA5</Address>
      <Comment>mState == PlantState::STATE_SQUASH_DONE_FALLING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BAE</Address>
      <Comment>mSquished
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BBB</Address>
      <Comment>mOnBungeeState == PlantOnBungeeState::RISING_WITH_BUNGEE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BC8</Address>
      <Comment>mDead
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BCF</Address>
      <Comment>462CCC为返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BD5</Address>
      <Comment>if (!mIsAsleep)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BDE</Address>
      <Comment>mSeedType == SeedType::SEED_CHERRYBOMB
以下的条件跳转472BFD为"压炸"的原理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BE3</Address>
      <Comment>mSeedType == SeedType::SEED_JALAPENO
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BE8</Address>
      <Comment>mSeedType == SeedType::SEED_DOOMSHROOM
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BED</Address>
      <Comment>mSeedType == SeedType::SEED_ICESHROOM
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BF2</Address>
      <Comment>mSeedType == SeedType::SEED_POTATOMINE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BF7</Address>
      <Comment>mState != PlantState::STATE_NOTREADY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BFD</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62BFE</Address>
      <Comment>aPlant-&gt;DoSpecial();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C0A</Address>
      <Comment>mSeedType == SeedType::SEED_SQUASH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C0F</Address>
      <Comment>mState != PlantState::STATE_NOTREADY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C19</Address>
      <Comment>mRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C1C</Address>
      <Comment>mRow * (int)RenderLayer::RENDER_LAYER_ROW_OFFSET
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C22</Address>
      <Comment>mRow * (int)RenderLayer::RENDER_LAYER_ROW_OFFSET + RenderLayer::RENDER_LAYER_GRAVE_STONE + 8

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C27</Address>
      <Comment>mRenderOrder = Board::MakeRenderOrder(RenderLayer::RENDER_LAYER_GRAVE_STONE, mRow, 8);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C2A</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C2D</Address>
      <Comment>mSquished = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C34</Address>
      <Comment>mDisappearCountdown = 500;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C3B</Address>
      <Comment>if (!mMuteSoundsForCutscene)
又是PlayFoley的函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C69</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C6A</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C7D</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C7E</Address>
      <Comment>eax = FoleyType theFoleyType
/*FoleyType::FOLEY_SQUISH*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C83</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C86</Address>
      <Comment>ecx = TodFoley* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C8D</Address>
      <Comment>esi = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C8F</Address>
      <Comment>RemoveEffects();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C94</Address>
      <Comment>edi = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C97</Address>
      <Comment>ebx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C9A</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C9D</Address>
      <Comment>GridItemType theGridItemType
/*GridItemType::GRIDITEM_LADDER*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62C9F</Address>
      <Comment>函数展开,展开前:
GetGridItemAt(GridItemType::GRIDITEM_LADDER, theGridX, theGridY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CA4</Address>
      <Comment>if (aLadder)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CA8</Address>
      <Comment>esi = GridItem* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CAA</Address>
      <Comment>aLadder-&gt;GridItemDie();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CAF</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CB2</Address>
      <Comment>mApp-&gt;IsIZombieLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CB7</Address>
      <Comment>if (mApp-&gt;IsIZombieLevel())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CBB</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CBE</Address>
      <Comment>mBoard-&gt;mChallenge属性

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CC4</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CC5</Address>
      <Comment>esi = Plant* thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CC7</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;IZombiePlantDropRemainingSun(this);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+62CCC</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664B0</Address>
      <Comment>植物指针是edi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664B3</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664B4</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664B9</Address>
      <Comment>int aDamageRangeFlags = GetDamageRangeFlags(PlantWeapon::WEAPON_PRIMARY);
关注点:如果是火爆辣椒,那么会返回127
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664BE</Address>
      <Comment>edx被赋值为mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664C1</Address>
      <Comment>又要遍历僵尸了,用法同理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664C5</Address>
      <Comment>如果是火爆辣椒,这里会把ebx赋值为127
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664CF</Address>
      <Comment>mBoard-&gt;IterateZombies(aZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664D4</Address>
      <Comment>while (mBoard-&gt;IterateZombies(aZombie))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664D6</Address>
      <Comment>若遍历失败则跳转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664DA</Address>
      <Comment>又是弱智代码?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664E0</Address>
      <Comment>esi被赋值为僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664E4</Address>
      <Comment>取得僵尸行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664E7</Address>
      <Comment>僵尸行数-=植物行数
这不会实质上改变僵尸行数,刚刚的说法只是为了便于理解而已

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664EA</Address>
      <Comment>僵尸的类型是僵王吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664EE</Address>
      <Comment>如果是僵王则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664F0</Address>
      <Comment>在刚刚的操作之后,eax会被设置为僵尸与植物行数的差值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664F2</Address>
      <Comment>如果僵尸和植物不同行则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664F4</Address>
      <Comment>如果是僵王则跳转到这里
因为僵王无需判断攻击范围问题
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664F5</Address>
      <Comment>aZombie-&gt;EffectedByDamage(aDamageRangeFlags)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664FA</Address>
      <Comment>僵尸在可攻击范围内吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664FC</Address>
      <Comment>如果不在,则跳走,判断下一个僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+664FE</Address>
      <Comment>处理僵尸被火烧解冻的问题
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66505</Address>
      <Comment>if (mIceTrapCounter &gt; 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66507</Address>
      <Comment>进行了函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66509</Address>
      <Comment>mZombie-&gt;RemoveIceTrap()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6650E</Address>
      <Comment>if (mChilledCounter &gt; 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66521</Address>
      <Comment>UpdateAnimSpeed()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66528</Address>
      <Comment>ApplyBurn()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66534</Address>
      <Comment>再次遍历僵尸,即决定是否进行下一轮循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6653D</Address>
      <Comment>edx = mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6654C</Address>
      <Comment>mBoard-&gt;IterateGridItems(aGridItem)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66551</Address>
      <Comment>while (mBoard-&gt;IterateGridItems(aGridItem))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66553</Address>
      <Comment>现在遍历的是场地物品,不再是僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66555</Address>
      <Comment>3对应梯子
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6655A</Address>
      <Comment>?弱智代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66560</Address>
      <Comment>esi被赋值为场地物品,接下来同理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66564</Address>
      <Comment>eax被赋值为场地物品的判定高度,即行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6656D</Address>
      <Comment>物品是梯子吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66572</Address>
      <Comment>aGridItem-&gt;GridItemDie();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66577</Address>
      <Comment>再次遍历场地物品,判断是否进入下一轮循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6658A</Address>
      <Comment>Zombie* aBossZombie = mBoard-&gt;GetBossZombie();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66591</Address>
      <Comment>如果没有获取到僵王信息,就跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66593</Address>
      <Comment>[esp+14]对应于参数theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66597</Address>
      <Comment>比较当前行和僵王冰火球行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6659F</Address>
      <Comment>aBossZombie-&gt;BossDestroyIceballInRow(theRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665B0</Address>
      <Comment>void Plant::BlowAwayFliers()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665B3</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665B5</Address>
      <Comment>精准堆栈,获取植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665B9</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665BC</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665BE</Address>
      <Comment>esi = Zombie*&amp; theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665C2</Address>
      <Comment>Zombie* aZombie = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665CA</Address>
      <Comment>mBoard-&gt;IterateZombies(aZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665CF</Address>
      <Comment>while (mBoard-&gt;IterateZombies(aZombie))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665D1</Address>
      <Comment>若不满足条件跳转至while的结束位置
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665D3</Address>
      <Comment>获取遍历到的僵尸指针

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665D7</Address>
      <Comment>aZombie-&gt;mDead
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665E0</Address>
      <Comment>僵尸状态
bool Zombie::IsDeadOrDying()函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665E3</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_ZOMBIE_DYING

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665E8</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_ZOMBIE_BURNED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665ED</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_ZOMBIE_MOWERED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665F2</Address>
      <Comment>edi = _Out_ Rect&amp;&amp; aZombieRect
/*ebx = Zombie* this无需额外传参,因为ebx已经是僵尸指针了*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665F6</Address>
      <Comment>参考源码:aZombie-&gt;GetZombieRect()
有出入
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665FB</Address>
      <Comment>获取僵尸状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+665FE</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_BALLOON_FLYING
总之,只有eax==49||eax==4A是会执行46660D
否则直接到466614


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66603</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_BALLOON_POPPING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66608</Address>
      <Comment>代码混淆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6660D</Address>
      <Comment>aZombie-&gt;mBlowingAway = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66614</Address>
      <Comment>这是判断下一轮while循环的地方
edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66617</Address>
      <Comment>esi = Zombie*&amp; theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6661B</Address>
      <Comment>mBoard-&gt;IterateZombies(aZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66620</Address>
      <Comment>下一轮判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66624</Address>
      <Comment>while已经结束了!
ecx = LwanApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66627</Address>
      <Comment>获取虚函数地址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66629</Address>
      <Comment>(41)
SOUND_BLOVER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6662F</Address>
      <Comment>继续获取虚函数地址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66635</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66636</Address>
      <Comment>经测试为4560C0
mApp-&gt;PlaySample(SOUND_BLOVER);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66638</Address>
      <Comment>获取mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6663B</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6663E</Address>
      <Comment>mBoard-&gt;mFogBlownCountDown = 4000;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66649</Address>
      <Comment>恢复局部变量区域
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6664C</Address>
      <Comment>带非寄存器参数返回

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666A0</Address>
      <Comment>Plant::DoSpecial(Plant* this)分析
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666A1</Address>
      <Comment>没有发现保存易变寄存器
这是一个教科书级别的函数代码

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666A3</Address>
      <Comment>栈对齐
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666A9</Address>
      <Comment>出现了:易变寄存器
但是这里的易变寄存器保存操作并不是连续的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666AA</Address>
      <Comment>堆栈寻址,获取植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666AD</Address>
      <Comment>植物受伤判定宽度基准mWidth

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666B0</Address>
      <Comment>mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666B3</Address>
      <Comment>???
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666B4</Address>
      <Comment>???
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666B6</Address>
      <Comment>mWidth/2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666B8</Address>
      <Comment>int aPosX = mX + mWidth / 2;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666BA</Address>
      <Comment>mHeight
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666BD</Address>
      <Comment>???
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666BE</Address>
      <Comment>???
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C0</Address>
      <Comment>mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C3</Address>
      <Comment>又一个易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C4</Address>
      <Comment>mHeight/2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C6</Address>
      <Comment>mY+mHeight/2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C8</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666C9</Address>
      <Comment>执行完毕后,esi=aPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666CB</Address>
      <Comment>执行完毕后,edi=aPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666CD</Address>
      <Comment>PlantWeapon thePlantWeapon
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666CF</Address>
      <Comment>eax = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666D1</Address>
      <Comment>aPosX局部变量保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666D5</Address>
      <Comment>aPosY局部变量保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666D9</Address>
      <Comment>GetDamageRangeFlags(PlantWeapon::WEAPON_PRIMARY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666DE</Address>
      <Comment>int aDamageRangeFlags = GetDamageRangeFlags(PlantWeapon::WEAPON_PRIMARY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666E2</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666E5</Address>
      <Comment>三叶草
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666EA</Address>
      <Comment>PlantState::STATE_DOINGSPECIAL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666EF</Address>
      <Comment>if (mState != PlantState::STATE_DOINGSPECIAL)
[+3C]为获取植物状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666F8</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666F9</Address>
      <Comment>mState = PlantState::STATE_DOINGSPECIAL;
此条指令夹在函数传参与调用之间
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+666FC</Address>
      <Comment>BlowAwayFliers();
参考源码是:BlowAwayFliers(mX, mRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66701</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6670A</Address>
      <Comment>樱桃
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66713</Address>
      <Comment>基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66717</Address>
      <Comment>if (!mMuteSoundsForCutscene)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66720</Address>
      <Comment>(69FAD0)
又是函数展开,详情见UpdateZombieGatlingHead的分析
因为形参与局部变量位置不同,函数展开后代码有所区别
但是大体上一致
mApp-&gt;PlayFoley(FoleyType::FOLEY_THROW);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66747</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66748</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6674B</Address>
      <Comment>Sexy::Rand(aFoleyParams-&gt;mPitchRange)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66754</Address>
      <Comment>调用者平衡堆栈
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6675B</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66760</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66763</Address>
      <Comment>eax = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66768</Address>
      <Comment>函数展开结束
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6676D</Address>
      <Comment>有两次PlayFiley函数调用,故又一次展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667A1</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667A2</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667A5</Address>
      <Comment>Sexy::Rand(aFoleyParams-&gt;mPitchRange)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667AE</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667B5</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667B6</Address>
      <Comment>ecx = TodFoley* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667BA</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667BD</Address>
      <Comment>eax = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667C2</Address>
      <Comment>PlayFoleyPitch(theFoleyType, aPitch)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667C9</Address>
      <Comment>这条指令等于什么事也不做
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667CB</Address>
      <Comment>获取局部变量aDamageRangeFlags保存至edx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667CF</Address>
      <Comment>获取植物所在行保存至eax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667D2</Address>
      <Comment>mBoard保存至ecx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667D5</Address>
      <Comment>int theDamageRangeFlags
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667D6</Address>
      <Comment>bool theBurn

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667D8</Address>
      <Comment>int theRowRange
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667DA</Address>
      <Comment>int theRadius
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667DC</Address>
      <Comment>int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667DD</Address>
      <Comment>int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667DE</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667DF</Address>
      <Comment>Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667E0</Address>
      <Comment>该函数的参数类型与参考源码有出入
参考源码:mBoard-&gt;KillAllZombiesInRadius(mRow, aPosX, aPosY, 115, 1, true, aDamageRangeFlags);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667E5</Address>
      <Comment>函数展开行为,参考源码:
mApp-&gt;AddTodParticle(aPosX, aPosY, (int)RenderLayer::RENDER_LAYER_TOP, ParticleEffect::PARTICLE_POWIE);
[esp+0C]是aPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667E9</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667EB</Address>
      <Comment>mEffectSystem
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667F1</Address>
      <Comment>mParticleHolder
esi = TodParticleHolder* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667F3</Address>
      <Comment>ParticleEffect theParticleEffect
/*ParticleEffect::PARTICLE_POWIE*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667F5</Address>
      <Comment>int theRenderOrder
/*(int)RenderLayer::RENDER_LAYER_TOP*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667FA</Address>
      <Comment>浮点数传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+667FD</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66801</Address>
      <Comment>aPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66805</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66808</Address>
      <Comment>mEffectSystem-&gt;mParticleHolder-&gt;AllocParticleSystem(theX, theY, theRenderOrder, theEffect);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6680D</Address>
      <Comment>跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66812</Address>
      <Comment>毁灭菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66817</Address>
      <Comment>mApp
ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66819</Address>
      <Comment>mApp-&gt;mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6681B</Address>
      <Comment>(100)
SOUND_DOOMSHROOM
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66826</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66827</Address>
      <Comment>虚函数PlaySample
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66829</Address>
      <Comment>aDamageRangeFlags
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6682D</Address>
      <Comment>植物行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66830</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66833</Address>
      <Comment>int theDamageRangeFlags
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66834</Address>
      <Comment>bool theBurn
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66836</Address>
      <Comment>int theRowRange
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66838</Address>
      <Comment>int theRadius
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6683D</Address>
      <Comment>int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6683E</Address>
      <Comment>int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6683F</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66840</Address>
      <Comment>Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66841</Address>
      <Comment>参考源码:mBoard-&gt;KillAllZombiesInRadius(mRow, aPosX, aPosY, 250, 3, true, aDamageRangeFlags);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66846</Address>
      <Comment>edi = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66848</Address>
      <Comment>KillAllPlantsNearDoom();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6684D</Address>
      <Comment>aPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66859</Address>
      <Comment>esi = TodParticleHolder* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6685B</Address>
      <Comment>ParticleEffect theParticleEffect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6685D</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66862</Address>
      <Comment>浮点数传参的占位可以通过push ecx这种语句来进行
也可以像这样手动对esp做减法
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66865</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66869</Address>
      <Comment>aPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6686D</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66870</Address>
      <Comment>mApp-&gt;AddTodParticle(aPosX, aPosY, (int)RenderLayer::RENDER_LAYER_TOP, ParticleEffect::PARTICLE_DOOM);
但是进行了函数展开:展开为:
mEffectSystem-&gt;mParticleHolder-&gt;AllocParticleSystem(theX, theY, theRenderOrder, theEffect);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66875</Address>
      <Comment>植物所在列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66878</Address>
      <Comment>edi = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6687B</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6687E</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6687F</Address>
      <Comment>mBoard-&gt;AddACrater(mPlantCol, mRow)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66884</Address>
      <Comment>设置弹坑冷却时间
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66890</Address>
      <Comment>辣椒
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66899</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6689B</Address>
      <Comment>又来了:PlayFoley函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6689D</Address>
      <Comment>mMuteSoundsForCutscene
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668C9</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668D2</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668D6</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668DD</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668DE</Address>
      <Comment>eax = FoleyType theFoleyType
FoleyType::FOLEY_JALAPENO_IGNITE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668E3</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+668E6</Address>
      <Comment>ecx = TodFoley* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6691D</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6691E</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66931</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66932</Address>
      <Comment>eax = FoleyType theFoleyType
FoleyType::FOLEY_JUICY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66937</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6693A</Address>
      <Comment>ecx = TodFoley* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66943</Address>
      <Comment>代码混淆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66945</Address>
      <Comment>获取植物所在行
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66948</Address>
      <Comment>ebx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6694B</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6694C</Address>
      <Comment>mBoard-&gt;DoFwoosh(mRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66951</Address>
      <Comment>精准堆栈寻址,获取植物指针
edi = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66954</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66957</Address>
      <Comment>mBoard-&gt;mShakeCounter=12;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66961</Address>
      <Comment>mBoard-&gt;mShakeAmountX=3
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6696B</Address>
      <Comment>mBoard-&gt;mShakeAmountY=-4
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66975</Address>
      <Comment>获取植物所在行mRow

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66978</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66979</Address>
      <Comment>BurnRow(mRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6697E</Address>
      <Comment>植物所在行
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66981</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66984</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66985</Address>
      <Comment>mBoard-&gt;mIceTimer[mRow] = 20;
二次偏移变址寻址
(该行冰道消失倒计时设为20)
(为什么不是0?因为辣椒爆炸需要一个过程)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66990</Address>
      <Comment>Die();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6699E</Address>
      <Comment>保护伞
虽然不是一次性植物,但是也调用这个函数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669A3</Address>
      <Comment>植物状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669A6</Address>
      <Comment>叶子保护伞触发

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669AF</Address>
      <Comment>叶子保护伞弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669BE</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669BF</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669C2</Address>
      <Comment>ReanimLoopType theLoopType
/*ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669C4</Address>
      <Comment>("anim_block")
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669C9</Address>
      <Comment>ecx = int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669CB</Address>
      <Comment>eax = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669CD</Address>
      <Comment>mState = PlantState::STATE_UMBRELLA_TRIGGERED;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669D4</Address>
      <Comment>mStateCountdown = 5;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669DB</Address>
      <Comment>PlayBodyReanim("anim_block", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 0, 22.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669E9</Address>
      <Comment>寒冰菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669EE</Address>
      <Comment>编译器的代码混淆手段
mov esi,12/*FoleyType::FOLEY_FROZEN*/
esi = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669F1</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669F3</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_FROZEN);
很奇怪,这次居然没有函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669F8</Address>
      <Comment>edi = Plant* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669FA</Address>
      <Comment>IceZombies();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+669FF</Address>
      <Comment>aPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A03</Address>
      <Comment>mApp
edx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A05</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A08</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A0C</Address>
      <Comment>eax = ParticleEffect theEffect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A0F</Address>
      <Comment>aPosX
由于刚刚esp发生了变动,所以寻址也需要改变
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A13</Address>
      <Comment>ecx = int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A18</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A1B</Address>
      <Comment>mApp-&gt;AddTodParticle(aPosX, aPosY, (int)RenderLayer::RENDER_LAYER_TOP, ParticleEffect::PARTICLE_ICE_TRAP);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A20</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A21</Address>
      <Comment>Die();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A2F</Address>
      <Comment>地雷
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A38</Address>
      <Comment>(49)
SOUND_POTATO_MINE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A3D</Address>
      <Comment>到目前为止,ecx仍然是mX + mWidth / 2
mX + mWidth / 2 - 20
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A40</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A44</Address>
      <Comment>获取虚函数指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A4A</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A4B</Address>
      <Comment>重制aPosX
aPosX = mX + mWidth / 2 - 20;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A4F</Address>
      <Comment>aPosY = mY + mHeight / 2;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A53</Address>
      <Comment>又是多态
4560C0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A55</Address>
      <Comment>aDamageRangeFlags

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A59</Address>
      <Comment>所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A5C</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A5F</Address>
      <Comment>int theDamageRangeFlags
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A60</Address>
      <Comment>bool theBurn
在原版中,土豆雷虽然会爆炸,但是不属于灰烬植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A62</Address>
      <Comment>int theRowRange
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A64</Address>
      <Comment>int theRadius
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A66</Address>
      <Comment>int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A67</Address>
      <Comment>int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A68</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A69</Address>
      <Comment>Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A6A</Address>
      <Comment>参考源码:
再次强调,参考源码与实际的参数类型不同!:
mBoard-&gt;KillAllZombiesInRadius(mRow, aPosX, aPosY, 60, 0, false, aDamageRangeFlags);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A6F</Address>
      <Comment>Board::MakeRenderOrder函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A73</Address>
      <Comment>mRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A76</Address>
      <Comment>/*mApp*/
edx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A78</Address>
      <Comment>imul ecx,RenderLayer::RENDER_LAYER_ROW_OFFSET
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A7E</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A81</Address>
      <Comment>("er-|1-1-2")
CE自动生成的注释有误
应该是RenderLayer::RENDER_LAYER_PARTICLE
ecx = int theRenderOrder
现在ecx已经是Board::MakeRenderLayer的返回值了
同时也是LawnApp::AddTodParticle的实参
对应于参考源码的aRenderPosition
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A87</Address>
      <Comment>eax = ParticleEffect theEffect
/*ParticleEffect::PARTICLE_POTATO_MINE*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A8C</Address>
      <Comment>/*aPosY*/
float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A90</Address>
      <Comment>aPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A94</Address>
      <Comment>(20.00)
aPosX+20.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66A9A</Address>
      <Comment>画蛇添足的临时保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AA2</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AA5</Address>
      <Comment>mApp-&gt;AddTodParticle(aPosX + 20.0f, aPosY, aRenderPosition, ParticleEffect::PARTICLE_POTATO_MINE);
此次居然又没有进行函数展开,大大降低了分析难度

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AAA</Address>
      <Comment>获取mBoard
这是好几个一次性植物的公用代码段
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AAD</Address>
      <Comment>mBoard-&gt;mShakeCounter=12;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AB7</Address>
      <Comment>mBoard-&gt;mShakeAmountX=3
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AC1</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AC2</Address>
      <Comment>mBoard-&gt;mShakeAmountY=-4
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66ACC</Address>
      <Comment>任何完成使命的植物都应该去世
Die();

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66ADA</Address>
      <Comment>咖啡豆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66ADD</Address>
      <Comment>如果仍然不相等,那就只能直接返回了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AE3</Address>
      <Comment>植物所在列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AE6</Address>
      <Comment>GetTopPlantAt又被函数展开了
展开前:GetTopPlantAt(mPlantCol, mRow, PlantPriority::TOPPLANT_ONLY_NORMAL_POSITION)
判断植物横向是否越界

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AE9</Address>
      <Comment>植物所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AEC</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AF1</Address>
      <Comment>判断植物纵向是否越界
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AF6</Address>
      <Comment>mBoard-&gt;mApp
ecx = LawnApp* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66AFC</Address>
      <Comment>mApp-&gt;IsWallnutBowlingLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B01</Address>
      <Comment>if (mApp-&gt;IsWallnutBowlingLevel()...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B05</Address>
      <Comment>eax = CutScene* this
/*mBoard-&gt;mCutScene*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B0B</Address>
      <Comment>mCutScene-&gt;IsInShovelTutorial()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B12</Address>
      <Comment>if (...!mCutScene-&gt;IsInShovelTutorial())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B14</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B15</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B16</Address>
      <Comment>ebx = _Out_ PlantsOnLawn* thePlantOnLawn
还是要注意堆栈寻址问题
在正常堆栈下,对应[esp+20]

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B1A</Address>
      <Comment>GetPlantsOnLawn(theGridX, theGridY, &amp;aPlantOnLawn);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B1F</Address>
      <Comment>常规植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B23</Address>
      <Comment>if (aPlant...)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B27</Address>
      <Comment>if (...aPlant-&gt;mIsAsleep)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B30</Address>
      <Comment>aPlant-&gt;mWakeUpCounter = 100;
植物醒来需要100缓冲时间
也就是说咖啡豆生效需要1秒时间
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B43</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B44</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B47</Address>
      <Comment>ReanimLoopType theLoopType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B49</Address>
      <Comment>("anim_crumble")
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B4E</Address>
      <Comment>ecx = int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B53</Address>
      <Comment>eax = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B55</Address>
      <Comment>mState = PlantState::STATE_DOINGSPECIAL;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B5C</Address>
      <Comment>参考源码:(注意参数类型有出入)
PlayBodyReanim("anim_crumble", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 22.0f);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B61</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B63</Address>
      <Comment>esi = FoleyType theFoleyType
/*FoleyType::FOLEY_COFFEE*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B68</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_COFFEE);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+66B6D</Address>
      <Comment>例行返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67381</Address>
      <Comment>else if (mSeedType == SeedType::SEED_CATTAIL)
是否为猫尾草?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67390</Address>
      <Comment>aProjectile-&gt;mVelX = 2.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67393</Address>
      <Comment>aProjectile-&gt;mMotionType = ProjectileMotion::MOTION_HOMING;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+673A0</Address>
      <Comment>aProjectile-&gt;mTargetZombieID = mBoard-&gt;ZombieGetID(theTargetZombie);
通过ecx中转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679B0</Address>
      <Comment>Plant::Die(Plant* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679B4</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679B5</Address>
      <Comment>堆栈寻址,获取植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679B9</Address>
      <Comment>if (!mIsOnBoard)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679C0</Address>
      <Comment>易变寄存器继续
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679C4</Address>
      <Comment>一个规律:如果在某个地方使用了某个寄存器来存储植物/僵尸指针
那么在之后的函数体内会一直使用这个寄存器保存该项指针
植物类型是缠绕水草吗?
缠绕水草去世时,需要把缠住的僵尸也顺便带走

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679CA</Address>
      <Comment>获取mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679CD</Address>
      <Comment>目标僵尸编号
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679D3</Address>
      <Comment>mBoard-&gt;mZombies
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679D9</Address>
      <Comment>目标僵尸编号为空(0)吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679DB</Address>
      <Comment>4679FC是一个公共代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679DD</Address>
      <Comment>dx数据传送至eax并进行符号位扩展
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679E0</Address>
      <Comment>[ecx+08]对应mBlock属性
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679E5</Address>
      <Comment>sizeof(Zombie)=15C
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679EB</Address>
      <Comment>这是在进行数组寻址
寻址完毕后eax是僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679ED</Address>
      <Comment>比较一下两个僵尸ID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679F5</Address>
      <Comment>ecx = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679F7</Address>
      <Comment>aZombie-&gt;DieWithLoot();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679FC</Address>
      <Comment>esi = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+679FE</Address>
      <Comment>mDead = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A05</Address>
      <Comment>RemoveEffects();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A0A</Address>
      <Comment>判断植物类型是不是咖啡豆
消梯问题被函数展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A10</Address>
      <Comment>mIsOnBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A17</Address>
      <Comment>若!mIsOnBoard则跳转至返回

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A1D</Address>
      <Comment>edi = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A20</Address>
      <Comment>ebx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A23</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A26</Address>
      <Comment>GridItemType theGridItemType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A28</Address>
      <Comment>参考源代码:mBoard-&gt;GetLadderAt(mPlantCol, mRow)
展开后:GetGridItemAt(GridItemType::GRIDITEM_LADDER, theGridX, theGridY);
结果为aLadder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A2D</Address>
      <Comment>和参考源代码有些不一样，注意一下
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A31</Address>
      <Comment>消梯
esi = GridItem* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A33</Address>
      <Comment>aLadder-&gt;GridItemDie();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A38</Address>
      <Comment>mIsOnBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A45</Address>
      <Comment>植物列数
很好!GetTopPlantAt又又又被展开了

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A4B</Address>
      <Comment>行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A4E</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A53</Address>
      <Comment>行数越界判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A58</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A5E</Address>
      <Comment>mApp-&gt;IsWalluntBowlingLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A67</Address>
      <Comment>mCutScene
eax = CutScene* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A6D</Address>
      <Comment>!mCutScene-&gt;IsInShovelTutorial()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A76</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A77</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A78</Address>
      <Comment>ebx = _Out_ PlantsOnLawn* thePlantOnLawn
在堆栈平衡状态下应该是[esp+10]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A7C</Address>
      <Comment>GetPlantsOnLawn(theGridX, theGridY, &amp;aPlantOnLawn);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A81</Address>
      <Comment>飞行植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A89</Address>
      <Comment>常规植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A91</Address>
      <Comment>南瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67A99</Address>
      <Comment>底盘

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AA1</Address>
      <Comment>GetTopPlantAt展开后的返回值保存至esi
获取植物列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AA4</Address>
      <Comment>ebx = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AA7</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AAA</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AAB</Address>
      <Comment>Plant* aFlowerPot = mBoard-&gt;GetFlowerPotAt(mPlantCol, mRow);
结果直接保存在寄存器,不进入内存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AB0</Address>
      <Comment>if (aFlowerPot...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AB4</Address>
      <Comment>if (...aTopPlant == aFlowerPot)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67ABB</Address>
      <Comment>(5.00)
编译自15.0-10.0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AD8</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67ADC</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67ADF</Address>
      <Comment>执行完毕后,esi就是ReanimationGet的返回值
ReanimationGet函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AE1</Address>
      <Comment>Rand(theMax - theMin)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AEF</Address>
      <Comment>aPotReanim-&gt;mAnimRate = RandRangeFloat(10.0f, 15.0f);
解释:花盆在上面有植物和上面没有植物时运动动画与动画速度有区别
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+67AF2</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAA0</Address>
      <Comment>重新分析该函数代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAA3</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAA4</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAA5</Address>
      <Comment>通过精准的堆栈平衡把控,获取子弹指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAA9</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAAA</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAAB</Address>
      <Comment>返回地址已经在[esp+20]了
esp+10对应于某个局部变量
ecx = _Out_ Rect&amp;&amp; aRect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAAF</Address>
      <Comment>esi = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAB1</Address>
      <Comment>参考源码:Rect aProjectileRect = GetProjectileRect();
实际上的函数表中是通过引用来返回aProjectileRect的,明白意思就行
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAB6</Address>
      <Comment>子弹矩形-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CABA</Address>
      <Comment>获取子弹矩形-&gt;mX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CABE</Address>
      <Comment>局部变量使用了形参的地址空间
在这后子弹指针就要通过ebp来访问了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAC8</Address>
      <Comment>代码混淆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAD0</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAD3</Address>
      <Comment>esi = Plant*&amp; thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAD7</Address>
      <Comment>while (mBoard-&gt;IteratePlants(aPlant))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CADC</Address>
      <Comment>判断是否找到了植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CADE</Address>
      <Comment>如果没找到就跳出循环
实际效果等同于直接返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAE4</Address>
      <Comment>循环体开始
获取子弹所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAE7</Address>
      <Comment>aPlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAEB</Address>
      <Comment>获取植物所在行数
并与子弹所在行数作比较
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAEE</Address>
      <Comment>46CAD0代表着进行下一轮循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAF0</Address>
      <Comment>判断子弹类型是否是僵尸豌豆
因为除了僵尸豌豆外,还有cxk的篮球

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAF6</Address>
      <Comment>接下来这一堆cmp就是比较植物类型是否是应当躲避僵尸豌豆了
获取植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAF9</Address>
      <Comment>小喷菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CAFE</Address>
      <Comment>阳光菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB03</Address>
      <Comment>地雷
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB08</Address>
      <Comment>地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB0D</Address>
      <Comment>钢地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB12</Address>
      <Comment>莲叶
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB17</Address>
      <Comment>打中植物的处理逻辑
eax = _Out_ Rect&amp;&amp; aInjuryRect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB1B</Address>
      <Comment>ecx = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB1D</Address>
      <Comment>aPlant-&gt;GetPlantRect();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB22</Address>
      <Comment>GetRectOverlap函数被展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB26</Address>
      <Comment>现在,edi是子弹矩形,ecx是植物矩形
注意在刚刚的两个获取矩形的函数调用时,返回的矩形都保存在栈区而非堆区
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB28</Address>
      <Comment>if (rect1.mX &lt; rect2.mX)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB2A</Address>
      <Comment>植物矩形-&gt;mWidth

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB2E</Address>
      <Comment>eax = rect1.mX + rect1.mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB31</Address>
      <Comment>rect2.mX+rect2.mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB39</Address>
      <Comment>eax = rect1.mX + rect1.mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB3B</Address>
      <Comment>ecx = 子弹矩形-&gt;mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB3D</Address>
      <Comment>子弹矩形-&gt;mX+子弹矩形-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB40</Address>
      <Comment>if (rect1.mX+rect1.mWidth &lt;= rect2.mX)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB44</Address>
      <Comment>rect1.mX+rect1.mWidth-rect2.mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB4C</Address>
      <Comment>“rmin - xmax”
很复杂的判断流程
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB54</Address>
      <Comment>if (GetRectOverlap(aProjectileRect, aPlantRect) &gt; 8)
注意GetRectOverLap被展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB57</Address>
      <Comment>判断下一个植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB5D</Address>
      <Comment>再次判断是否是僵尸豌豆
if (mProjectileType == ProjectileType::PROJECTILE_ZOMBIE_PEA)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB61</Address>
      <Comment>植物所在行数
GetTopPlantAt函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB64</Address>
      <Comment>mBoard
edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB67</Address>
      <Comment>植物所在列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB6C</Address>
      <Comment>从这里开始时僵尸豌豆的获取植物目标逻辑
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB78</Address>
      <Comment>如果植物越界则跳转到返回
return NULL;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB7E</Address>
      <Comment>ecx = LawnApp* this
获取基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB84</Address>
      <Comment>mApp-&gt;IsWallnutBowlingLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB89</Address>
      <Comment>if (mApp-&gt;IsWallnutBowlingLevel()...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB8D</Address>
      <Comment>eax = CutScene* this/*mBoard-&gt;mCutScene*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB93</Address>
      <Comment>mCutScene-&gt;IsInShovelTutorial()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CB9A</Address>
      <Comment>if (...!mCutScene-&gt;IsInShovelTutorial())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBA0</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBA1</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBA2</Address>
      <Comment>ebx = _Out_ PlantsOnLawn* thePlantOnLawn
PlantsOnLawn aPlantOnLawn;
对应于堆栈平衡状态下的[esp+10]

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBA6</Address>
      <Comment>另一个参数见46CB64
GetPlantsOnLawn(theGridX, theGridY, &amp;aPlantOnLawn);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBAB</Address>
      <Comment>为什么前面调用传入指针esp+18
现在又变成了esp+14呢?
因为在传入esp+18时已经进行了两次push
获取esp+14时堆栈被平回来了
总之就是这两个时间点的esp不一样

获取南瓜植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBB1</Address>
      <Comment>如果南瓜指针不为零,即存在南瓜则跳转(到返回)
由于返回值通过eax传递,所以等价于返回南瓜植物的指针

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBB3</Address>
      <Comment>常规植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBB9</Address>
      <Comment>判断常规植物是否存在,若存在则直接返回该常规植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBBB</Address>
      <Comment>返回底盘植物(花盆/莲叶)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBC9</Address>
      <Comment>cxk投出的篮球子弹的处理逻辑
比较植物所在列数有没有越界(原理同上)
if (mApp-&gt;IsWallnutBowlingLevel() &amp;&amp; !mCutScene-&gt;IsInShovelTutorial())
	return nullptr;
逻辑和前面几乎一模一样
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBCC</Address>
      <Comment>如果越界则跳转到返回空指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBD3</Address>
      <Comment>回忆一下edx是mBoard
ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBE2</Address>
      <Comment>eax = CutScene* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBF1</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBF2</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBF3</Address>
      <Comment>ebx = _Out_ PlantsOnLawn* thePlantOnLawn
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBF7</Address>
      <Comment>GetPlantsOnLawn(theGridX, theGridY, &amp;aPlantOnLawn);
大量重复代码
这就是典型的编译器犯傻行为,优化还不如不优化
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CBFC</Address>
      <Comment>但是到这里就稍有不同
获取飞行植物指针(因为毕竟是按照投掷优先级)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CC04</Address>
      <Comment>常规植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CC0C</Address>
      <Comment>南瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CC14</Address>
      <Comment>底盘
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD40</Address>
      <Comment>Projectile::FindCollisionTarget(Projectile* this)
堆栈传参,执行这条指令前,参数保存至[esp+4]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD43</Address>
      <Comment>这几个push全是保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD4B</Address>
      <Comment>PeaAboutToHitTorchwood()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD50</Address>
      <Comment>if (PeaAboutToHitTorchwood())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD52</Address>
      <Comment>如果子弹暂时还不会穿过树桩,则跳走到正常逻辑
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD60</Address>
      <Comment>局部变量,引用/指针传参

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD64</Address>
      <Comment>根据经验判断,edi里面也是子弹指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD66</Address>
      <Comment>Projectile::GetProjectileRect(ecx = _Out_ Rect&amp;&amp; aRect, esi = Projectile* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD6B</Address>
      <Comment>将mBoard赋值给edx
edx = Board* this


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD70</Address>
      <Comment>esi = Zombie*&amp; theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD80</Address>
      <Comment>mBoard-&gt;IterateZombies(aZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD85</Address>
      <Comment>while (mBoard-&gt;IterateZombies(aZombie))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD8D</Address>
      <Comment>ebp = aMinX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD91</Address>
      <Comment>将esi赋值为僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD95</Address>
      <Comment>获取僵尸所在行
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CD98</Address>
      <Comment>僵尸所在行与子弹所在行作减法比较
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDA0</Address>
      <Comment>僵尸是僵王吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDA5</Address>
      <Comment>eax存放了子弹与僵尸行数的差值,判断是否为零
(即僵尸和子弹是否在同一行)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDA7</Address>
      <Comment>不在同一行,就判断下一个僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDB1</Address>
      <Comment>aZombie-&gt;EffectedByDamage((unsigned int)mDamageRangeFlags)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDB6</Address>
      <Comment>if (... &amp;&amp; aZombie-&gt;EffectedByDamage((unsigned int)mDamageRangeFlags))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDB8</Address>
      <Comment>如果僵尸不会被打到,则跳走到下一个僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDBE</Address>
      <Comment>潜水僵尸正在跳水吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDCA</Address>
      <Comment>mPosZ &gt;= 45.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDD2</Address>
      <Comment>如果潜水僵尸正在跳水且满足纵向偏移条件,则判断下一个僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDD8</Address>
      <Comment>1437子弹需要特判
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDDE</Address>
      <Comment>子弹的存在计时是否已经超过了25?
ebx被复用了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDE1</Address>
      <Comment>如果杨桃子弹存在时间不超过25,也不进行处理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDE5</Address>
      <Comment>mVelX &gt;= 0.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDEF</Address>
      <Comment>子弹是玉米加农炮吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDF3</Address>
      <Comment>如果是,也要跳转到下一个僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CDFB</Address>
      <Comment>Zombie::GetZombieRect(edi = _Out_ Rect&amp;&amp; aZombieRect, ebx = Zombie* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE00</Address>
      <Comment>获取僵尸矩形的数据
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE04</Address>
      <Comment>if (aZombie-&gt;mX &lt; aMinX)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE1B</Address>
      <Comment>GetRectOverlap函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE35</Address>
      <Comment>GetRectOverlap函数展开完毕
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE37</Address>
      <Comment>如果结果小于零(即:没有重叠)则跳转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE39</Address>
      <Comment>if (aBestZombie == nullptr...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE66</Address>
      <Comment>下一轮while循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE6C</Address>
      <Comment>遍历完成
return aBestZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE80</Address>
      <Comment>继续分析代码
Projectile::CheckForCollision(Projectile* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE83</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE84</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE85</Address>
      <Comment>堆栈的局部变量和形参真是一个麻烦事
获取子弹指针,保存到ebp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE89</Address>
      <Comment>子弹运动方式
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE8C</Address>
      <Comment>mMotionType == ProjectileMotion::MOTION_PUFF
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE8F</Address>
      <Comment>仍然是保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE90</Address>
      <Comment>仍然是保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE91</Address>
      <Comment>如果子弹不是按照孢子的方式运动,则跳转
if (mMotionType == ProjectileMotion::MOTION_PUFF)
此时[esp+34]才是形参地址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE93</Address>
      <Comment>小喷子弹存在是否超过了75?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CE97</Address>
      <Comment>不小于则跳转,即:
小喷子弹应该消亡

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEA0</Address>
      <Comment>(800.00)
比较子弹横坐标有没有超过800.00,若超过也应该消亡
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEA6</Address>
      <Comment>将浮点标志位的值加载到ax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEB7</Address>
      <Comment>(0.00)
if (mPosX + mWidth &lt; 0.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEC8</Address>
      <Comment>if (mMotionType == ProjectileMotion::MOTION_HOMING)
ProjectileMotion::HOMING表示追踪
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CED1</Address>
      <Comment>香蒲刺的目标僵尸编号
ecx = ZombieID theZombieID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CED7</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEDA</Address>
      <Comment>mBoard-&gt;ZombieTryToGet(mTargetZombieID);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEE1</Address>
      <Comment>获取到的僵尸会不会为空呢?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEE3</Address>
      <Comment>如果为空则返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEE9</Address>
      <Comment>获取伤害类型theDamageRangeFlags
猫尾草的伤害类型是0B

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEEF</Address>
      <Comment>aZombie-&gt;EffectedByDamage((unsigned int)mDamageRangeFlags)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEF4</Address>
      <Comment>if (aZombie-&gt;EffectedByDamage((unsigned int)mDamageRangeFlags))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CEF6</Address>
      <Comment>如果打不到僵尸则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF02</Address>
      <Comment>Projectile::GetProjectileRect(ecx = _Out_ Rect&amp;&amp; aRect, esi = Projectile* this)
结果保存至[esp+20]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF0B</Address>
      <Comment>Zombie::GetZombieRect(edi = _Out_ Rect&amp;&amp; aZombieRect, ebx = Zombie* this)
结果保存至[esp+10]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF16</Address>
      <Comment>GetRectOverlap(aProjectileRect, aZombieRect)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF1B</Address>
      <Comment>猫尾草子弹需要专门碰撞检测,而不是调用FindTarget...
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF1D</Address>
      <Comment>if (GetRectOverlap(aProjectileRect, aZombieRect) &gt;= 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF23</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF26</Address>
      <Comment>aZombieRect.mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF31</Address>
      <Comment>若打不到则跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF37</Address>
      <Comment>ecx = aZombieRect.mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF3B</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF4C</Address>
      <Comment>mPosY &lt; aZombieRect.mY + aZombieRect.mHeight
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF53</Address>
      <Comment>条件跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF59</Address>
      <Comment>注意ebx是获取到的僵尸指针
eax = Zombie* theZombie = 0(默认参数)
此处进行了参数传递,故不使用默认参数

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF5B</Address>
      <Comment>ecx = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF5D</Address>
      <Comment>DoImpact(aZombie);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF6C</Address>
      <Comment>获取子弹类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF6F</Address>
      <Comment>是否是星星子弹?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF7A</Address>
      <Comment>mPosY &gt; 600.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CF9C</Address>
      <Comment>豌豆子弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFA0</Address>
      <Comment>星星子弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFB6</Address>
      <Comment>从46CF9C一直到这里,对应:
if ((mProjectileType == ProjectileType::PROJECTILE_PEA || mProjectileType == ProjectileType::PROJECTILE_STAR) &amp;&amp; mShadowY - mPosY &gt; 90.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFBC</Address>
      <Comment>回忆一下:
edx是子弹的运动方式
是否为"缓慢漂浮向右（无碰撞）"
??又是弱智代码?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFBF</Address>
      <Comment>如果是则跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFC8</Address>
      <Comment>在这个位置,ebp是子弹指针
Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFC9</Address>
      <Comment>如果不是僵尸豌豆,则跳转到下一个判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFCF</Address>
      <Comment>Plant* aPlant = FindCollisionTargetPlant()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFD6</Address>
      <Comment>如果打不到植物则跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFD8</Address>
      <Comment>获取子弹类型(肯定是0D)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFDB</Address>
      <Comment>mul ecx,3


现在来解释一下这里的代码究竟是怎么回事
它的实质应该是mov edx,ProjectileDefinition[0xD][0x2]

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFDE</Address>
      <Comment>ecx = 9C
69F1C0是gProjectileDefinition[]的位置
经过计算,偏移值是A4
获取僵尸豌豆的伤害值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFE5</Address>
      <Comment>获取植物发光倒计时
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFEB</Address>
      <Comment>植物血量-=伤害值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6CFEE</Address>
      <Comment>25,接下来的指令对应
aPlant-&gt;mEatenFlashCountdown = max(aPlant-&gt;mEatenFlashCountdown, 25);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D001</Address>
      <Comment>很重要,46D027会考
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D006</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_SPLAT);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D00B</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D00E</Address>
      <Comment>(17.00)
mPosY+17.00
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D014</Address>
      <Comment>图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D01D</Address>
      <Comment>浮点数传参,参数是mPosY+17.00
float Y

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D021</Address>
      <Comment>mRenderOrder + 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D027</Address>
      <Comment>eax = ParticleEffect theEffect
ParticleEffect::PARTICLE_PEA_SPLAT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D031</Address>
      <Comment>(3.00)
mPosX - 3.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D03F</Address>
      <Comment>float X
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D042</Address>
      <Comment>mApp-&gt;AddTodParticle(mPosX - 3.0f, mPosY + 17.0f, mRenderOrder + 1, ParticleEffect::PARTICLE_PEA_SPLAT);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D047</Address>
      <Comment>eax = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D049</Address>
      <Comment>Die()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D058</Address>
      <Comment>如果不是僵尸豌豆,就应该跳转到这里,注意刚刚已经进行了一次push ebp
eax = FindCollisionTarget()


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D05D</Address>
      <Comment>aZombie = eax,该变量保存在edx而非内存中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D05F</Address>
      <Comment>if (aZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D061</Address>
      <Comment>如果没有获取到僵尸则跳转到返回,注意这是向前跳转,实际上向后跳转也是可以的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D063</Address>
      <Comment>aZombie-&gt;mOnHighGround
僵尸是否在高地(内侧版第六大关)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D06A</Address>
      <Comment>如果僵尸不在高地上则跳转(此时能够打中僵尸)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D06C</Address>
      <Comment>ecx = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D06E</Address>
      <Comment>CantHitHighGround()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D075</Address>
      <Comment>不能打中高地则跳转(到返回)
注意这又是一个向前返回

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D077</Address>
      <Comment>eax = Zombie* theZombie = 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D079</Address>
      <Comment>ecx = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D07B</Address>
      <Comment>DoImpact(aZombie);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D230</Address>
      <Comment>Projectile::GetDamageFlags(eax = Zombie* theZombie, edi = Projectile* this)
获取子弹类型,保存至ecx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D233</Address>
      <Comment>本次函数代码分析中,只有一个易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D234</Address>
      <Comment>unsigned int aDamageFlags = 0U;
该变量被保存在esi中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D236</Address>
      <Comment>火豌豆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D23B</Address>
      <Comment>if (theZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D23F</Address>
      <Comment>僵尸种类
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D242</Address>
      <Comment>僵尸是投篮吗?
mZombieType == ZombieType::ZOMBIE_CATAPULT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D247</Address>
      <Comment>冰车
mZombieType == ZombieType::ZOMBIE_ZAMBONI
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D24C</Address>
      <Comment>mShieldType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D252</Address>
      <Comment>判断僵尸防具是不是铁门
mShieldType == ShieldType::SHIELDTYPE_DOOR
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D257</Address>
      <Comment>梯子
mShieldType == ShieldType::SHIELDTYPE_LADDER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D25A</Address>
      <Comment>下一个else if
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D25C</Address>
      <Comment>西瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D261</Address>
      <Comment>冰瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D266</Address>
      <Comment>火豌豆（再次判断）
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D26B</Address>
      <Comment>SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_HITS_SHIELD_AND_BODY, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D272</Address>
      <Comment>子弹的运动方式
从这里开始对应有一个else if

特别说明:
参考版源码是这样的:
else if (mMotionType == ProjectileMotion::MOTION_LOBBED || mMotionType == ProjectileMotion::MOTION_BACKWARDS)
{
	SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_BYPASSES_SHIELD, true);
}
else if (mMotionType == ProjectileMotion::MOTION_STAR &amp;&amp; mVelX &lt; 0.0f)
{
	SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_BYPASSES_SHIELD, true);
}

但是编译器发现两个执行体一模一样,所以将它们合并了:
else if (mMotionType == ProjectileMotion::MOTION_LOBBED || mMotionType == ProjectileMotion::MOTION_BACKWARDS || (mMotionType == ProjectileMotion::MOTION_STAR &amp;&amp; mVelX &lt; 0.0f))
{
	SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_BYPASSES_SHIELD, true);
}
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D275</Address>
      <Comment>抛物线
mMotionType == ProjectileMotion::MOTION_LOBBED
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D278</Address>
      <Comment>跳转到if判断的执行体,注意执行体只有一条指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D27A</Address>
      <Comment>水平向左
mMotionType == ProjectileMotion::MOTION_BACKWARDS
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D27F</Address>
      <Comment>斜向运动
mMotionType == ProjectileMotion::MOTION_STAR
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D286</Address>
      <Comment>mVelX &lt; 0.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D290</Address>
      <Comment>SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_BYPASSES_SHIELD, true);
因为SetBit是内联函数,所以被无条件展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D295</Address>
      <Comment>从这里开始将是下一个代码部分
mProjectileType == ProjectileType::PROJECTILE_SNOWPEA
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D29A</Address>
      <Comment>冰瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6D29F</Address>
      <Comment>SetBit(aDamageFlags, (int)DamageFlags::DAMAGE_FREEZE, true);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E000</Address>
      <Comment>Projectile::DoImpact(eax = Zombie* theZombie = 0, ecx = Projectile* this)
这个函数也需要重构
僵尸指针eax,子弹指针ecx

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E003</Address>
      <Comment>仍然是易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E007</Address>
      <Comment>保存eax僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E009</Address>
      <Comment>保存ecx子弹指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E00B</Address>
      <Comment>Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E00C</Address>
      <Comment>eax = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E00E</Address>
      <Comment>PlayImpactSound(theZombie);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E013</Address>
      <Comment>一定要注意到edi是子弹指针
获取子弹类型

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E016</Address>
      <Comment>子弹类型是火豌豆吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E01B</Address>
      <Comment>theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E01D</Address>
      <Comment>if (mProjectileType == ProjectileType::PROJECTILE_FIREBALL &amp;&amp; theZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E01F</Address>
      <Comment>获取僵尸类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E022</Address>
      <Comment>僵尸是投篮吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E027</Address>
      <Comment>冰车
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E02C</Address>
      <Comment>僵尸防具类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E032</Address>
      <Comment>僵尸防具是铁门吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E037</Address>
      <Comment>梯子
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E03A</Address>
      <Comment>这一大堆je 0046E065都是在处理溅射伤害问题
IsSplashDamage(theZombie)进行了函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E046</Address>
      <Comment>火豌豆进行了两次判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E050</Address>
      <Comment>无论怎么说:火豌豆的常规伤害在这里进行处理
当且仅当火豌豆击中僵尸且存在溅射,那么执行这里到46E063


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E054</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E056</Address>
      <Comment>Zombie::RemoveColdEffects(eax = Zombie* this)
theZombie-&gt;RemoveColdEffects();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E05B</Address>
      <Comment>Zombie* theZombie
一切溅射,无论是火豌豆还是西瓜冰西瓜伤害都在这里处理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E05C</Address>
      <Comment>eax = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E05E</Address>
      <Comment>DoSplashDamage(theZombie);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E065</Address>
      <Comment>对僵尸不存在溅射时,会执行这里到46E078
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E069</Address>
      <Comment>eax = Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E06B</Address>
      <Comment>edi已经是子弹指针了
GetDamageFlags(theZombie)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E070</Address>
      <Comment>又是代码混淆
总之,这等价于mov ecx,12(十六进制,对应十进制18)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E073</Address>
      <Comment>又来了...偏移量50
等价于mov edx,28(十进制:40)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E07A</Address>
      <Comment>int theDamage
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E07B</Address>
      <Comment>theZombie-&gt;TakeDamage(GetProjectileDef().mDamage, aDamageFlags);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E080</Address>
      <Comment>无论是否产生溅射,都会执行到这里
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E083</Address>
      <Comment>子弹图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E086</Address>
      <Comment>mPosX - mVelX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E089</Address>
      <Comment>子弹类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E08C</Address>
      <Comment>子弹图层+1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E08F</Address>
      <Comment>现在子弹类型是eax而非ebx了!
西瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E092</Address>
      <Comment>通过[esp+24]获取返回地址
当前的[esp+18]肯定是局部变量
float aLastPosX = mPosX - mVelX;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E096</Address>
      <Comment>mPosZ
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E099</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E09C</Address>
      <Comment>mVelY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E09F</Address>
      <Comment>mVelZ
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0A2</Address>
      <Comment>float aLastPosY = mPosY + mPosZ - mVelY - mVelZ;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0A6</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0AF</Address>
      <Comment>mPosX + 12.00f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0B3</Address>
      <Comment>float aSplatPosX = mPosX + 12.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0BA</Address>
      <Comment>float aSplatPosY = mPosY + 12.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0BE</Address>
      <Comment>远距离判断
此处利用的是cmp ebx,03的判断结果(46E08F)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0D4</Address>
      <Comment>aLastPosY + 30.0f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0D6</Address>
      <Comment>ParticleEffect::PARTICLE_MELONSPLASH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0DA</Address>
      <Comment>图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0F6</Address>
      <Comment>Die()
又是编译优化,因为Die()函数调用在DoImpact末尾,所以直接使用了跳转而非调用指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E0FB</Address>
      <Comment>如果子弹类型不是西瓜则跳转到这里
冰瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E100</Address>
      <Comment>冰瓜代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E116</Address>
      <Comment>ParticleEffect::PARTICLE_WINTERMELON
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E11A</Address>
      <Comment>图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E136</Address>
      <Comment>跳转到执行子弹效果的指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E13B</Address>
      <Comment>玉米炮
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E144</Address>
      <Comment>edi是子弹指针
mCobTargetRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E14A</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E14D</Address>
      <Comment>(40.00)
mPosY + 40.00f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E153</Address>
      <Comment>edx = 基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E155</Address>
      <Comment>10000
为什么会出现把行数乘以10000的离谱操作呢?
int Board::MakeRenderOrder(RenderLayer theRenderLayer, int theRow, int theLayerOffset)
{
	return theRow * (int)RenderLayer::RENDER_LAYER_ROW_OFFSET + theRenderLayer + theLayerOffset;
}
该函数被展开了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E163</Address>
      <Comment>动画信息
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E169</Address>
      <Comment>粒子系统
esi = TodParticleHolder* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E16B</Address>
      <Comment>ParticleEffect theEffect
ParticleEffect::PARTICLE_BLASTMARK
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E173</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E177</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E17E</Address>
      <Comment>(80.00)
mPosX+80.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E18C</Address>
      <Comment>float theX
浮点数传参是fstp [esp+...]
手动将浮点数赋值给栈顶附近元素
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E18F</Address>
      <Comment>mApp-&gt;AddTodParticle(mPosX + 80.0f, mPosY + 40.0f, aRenderOrder, ParticleEffect::PARTICLE_BLASTMARK);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E194</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E199</Address>
      <Comment>(40.00)
mPosY + 40.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1A5</Address>
      <Comment>esi = TodParticleHolder* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1A7</Address>
      <Comment>ParticleEffect theParticleEffect
ParticleEffect::PARTICLE_POPCORNSPLASH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1AD</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1B5</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1B9</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1BC</Address>
      <Comment>(80.00)
mPosX + 80.00
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1C2</Address>
      <Comment>临时保存?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1CA</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1CD</Address>
      <Comment>mApp-&gt;AddTodParticle(mPosX + 80.0f, mPosY + 40.0f, mRenderOrder + 1, ParticleEffect::PARTICLE_POPCORNSPLASH);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1D2</Address>
      <Comment>基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1D6</Address>
      <Comment>(100)
这是一个全局整型常量
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1E2</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1E3</Address>
      <Comment>LawnApp::PlaySample(int theSoundNum, ecx = LawnApp* this)
C++代码:mApp-&gt;PlaySample(SOUND_DOOMSHROOM);
这是一个虚函数多态调用
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1E5</Address>
      <Comment>以下是mBoard-&gt;ShakeBoard(3, -4);的函数展开

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1E8</Address>
      <Comment>mShakeCounter
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1F2</Address>
      <Comment>3,mShakeAmountX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E1FC</Address>
      <Comment>-4,mShakeAmountY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E206</Address>
      <Comment>用eax来保存子弹指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E20F</Address>
      <Comment>Die();
调用被优化为跳转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E214</Address>
      <Comment>此时eax仍然是子弹类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E216</Address>
      <Comment>如果子弹不是豌豆则跳转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E21C</Address>
      <Comment>mov ebp,25
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E225</Address>
      <Comment>aSplatPosX -= 15.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E22E</Address>
      <Comment>子弹类型是不是冰豌豆?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E237</Address>
      <Comment>mov ebp,2B
ParticleEffect::PARTICLE_SNOWPEA_SPLAT,
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E240</Address>
      <Comment>aSplatPosX -= 15.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E249</Address>
      <Comment>火豌豆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E24E</Address>
      <Comment>ecx = Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E250</Address>
      <Comment>eax = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E252</Address>
      <Comment>IsSplashDamage(theZombie)
为了绘制特效,需要再次判断溅射问题
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E257</Address>
      <Comment>if (IsSplashDamage(theZombie))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E259</Address>
      <Comment>如果不是,则直接跳转到返回
因为非溅射伤害无需绘制特效
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E25F</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E262</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E264</Address>
      <Comment>(20.00)
mPosY - 20.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E26E</Address>
      <Comment>ebx = ReanimationType theReanimationType
ReanimationType::REANIM_JALAPENO_FIRE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E273</Address>
      <Comment>临时保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E27B</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E27F</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E282</Address>
      <Comment>(38.00)
mPosX + 38.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E288</Address>
      <Comment>临时保存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E290</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E293</Address>
      <Comment>Reanimation* aFireReanim = mApp-&gt;AddReanimation(mPosX + 38.0f, mPosY - 20.0f, mRenderOrder + 1, ReanimationType::REANIM_JALAPENO_FIRE);
变量aFireReanim直接保存在寄存器中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E29E</Address>
      <Comment>aFireReanim-&gt;mAnimTime = 0.25f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2A7</Address>
      <Comment>aFireReanim-&gt;mAnimRate = 24.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2AA</Address>
      <Comment>(0.70)
以下是函数展开:
void Reanimation::OverrideScale(float theScaleX, float theScaleY)
{
	mOverlayMatrix.m00 = theScaleX;
	mOverlayMatrix.m11 = theScaleY;
}
aFireReanim-&gt;OverrideScale(0.7f, 0.4f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2C5</Address>
      <Comment>Die()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2CA</Address>
      <Comment>星星
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2CF</Address>
      <Comment>mov ebp,29
ParticleEffect::PARTICLE_STAR_SPLAT,

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2D2</Address>
      <Comment>跳转到公共代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2D4</Address>
      <Comment>孢子
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2D9</Address>
      <Comment>aSplatPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2DD</Address>
      <Comment>mov ebp,28
ParticleEffect::PARTICLE_PUFF_SPLAT

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2E0</Address>
      <Comment>(20.00)
aSplatPosX - 20.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2E6</Address>
      <Comment>aSplatPosX -= 20.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2EA</Address>
      <Comment>跳转到公共代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2EC</Address>
      <Comment>卷心菜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2F1</Address>
      <Comment>aLastPosX


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2F5</Address>
      <Comment>mov ebp,27
ParticleEffect::PARTICLE_CABBAGE_SPLAT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2F8</Address>
      <Comment>(38.00)
aLastPosX - 38.0f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E2FE</Address>
      <Comment>aSplatPosX = aLastPosX - 38.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E302</Address>
      <Comment>aLastPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E306</Address>
      <Comment>(23.00)
aLastPosY + 23.00
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E30C</Address>
      <Comment>aSplatPosY = aLastPosY + 23.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E310</Address>
      <Comment>跳转到公共代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E312</Address>
      <Comment>黄油
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E315</Address>
      <Comment>如果不是黄油,就直接跳转到返回了
(当然,"返回"只是一个便于理解的说法,实际上还需要调用Die())
特别关注:DoImpact函数似乎不存在对玉米粒的特殊处理逻辑
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E31B</Address>
      <Comment>esi是僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E31D</Address>
      <Comment>aLastPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E321</Address>
      <Comment>(20.00)
aLastPosX - 20.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E327</Address>
      <Comment>mov ebp,26
ParticleEffect::PARTICLE_BUTTER_SPLAT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E32A</Address>
      <Comment>aSplatPosX = aLastPosX - 20.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E32E</Address>
      <Comment>aLastPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E338</Address>
      <Comment>aSplatPosY = aLastPosY + 63.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E342</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E344</Address>
      <Comment>theZombie-&gt;ApplyButter();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E349</Address>
      <Comment>这是公共代码部分
判断僵尸指针是否为空
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E35E</Address>
      <Comment>获取僵尸状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E361</Address>
      <Comment>是否处于潜水入水状态?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E36C</Address>
      <Comment>float aPosX = aSplatPosX + 52.0f - theZombie-&gt;mX;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E383</Address>
      <Comment>海豚跳完之后
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E392</Address>
      <Comment>子弹运动类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E3A6</Address>
      <Comment>aPosX -= 80.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E408</Address>
      <Comment>ParticleEffect theEffect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E409</Address>
      <Comment>利用 SSE 相关指令将 st(0) 的浮点数强制转化为整数存储在 eax 中。
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E412</Address>
      <Comment>int thePosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E418</Address>
      <Comment>int thePosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E419</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E41B</Address>
      <Comment>theZombie-&gt;AddAttachedParticle(aPosX, aPosY, aEffect);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E422</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E42E</Address>
      <Comment>好像几乎不会执行到这里??
原因:只有46E33C和46E34B的跳转指令有可能执行到这里
但是这两个跳转都要求僵尸指针为空
在"鞭尸"的时候会执行到这里
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E43A</Address>
      <Comment>esi = TodParticleHolder* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E43C</Address>
      <Comment>ParticleEffect theParticleEffect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E43D</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E441</Address>
      <Comment>float theY/theX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E449</Address>
      <Comment>float theX/theY

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E44C</Address>
      <Comment>创建子弹效果
mApp-&gt;AddTodParticle(aLastPosX + 30.0f, aLastPosY + 30.0f, mRenderOrder + 1, ParticleEffect::PARTICLE_MELONSPLASH);
编译优化,源代码中并不是call 518A70

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E451</Address>
      <Comment>eax = Projectile* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6E460</Address>
      <Comment>Projectile::Update(eax = Projectile* this)
这已经是另一个函数的起始地址了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB20</Address>
      <Comment>Projectile::Die(eax = Projectile* this)
又是易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB23</Address>
      <Comment>mov esi,子弹指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB25</Address>
      <Comment>子弹类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB28</Address>
      <Comment>孢子
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB2B</Address>
      <Comment>mDead = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+6EB42</Address>
      <Comment>mAttachmentID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845E0</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845E2</Address>
      <Comment>精准堆栈,获取SeedChooserScreen
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845E6</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845EC</Address>
      <Comment>mBoard-&gt;SeedNotRecommendedForLevel(theSeedType);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845F3</Address>
      <Comment>TestBit(aRecFlags, NOT_RECOMMENDED_NOCTURNAL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845F8</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845F9</Address>
      <Comment>edi = SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+845FE</Address>
      <Comment>ecx = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84600</Address>
      <Comment>PickedPlantType(SEED_INSTANT_COFFEE)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84607</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8460A</Address>
      <Comment>SetBit(aRecFlags, NOT_RECOMMENDED_NOCTURNAL, false);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+849E9</Address>
      <Comment>esi = SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+849EC</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+849FE</Address>
      <Comment>[esp+18]是一个用于设置卡片高亮与否的局部变量
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84A1B</Address>
      <Comment>共用代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FD0</Address>
      <Comment>theChosenSeed.mSeedState
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FD6</Address>
      <Comment>if (theChosenSeed.mSeedState == SEED_FLYING_TO_BANK)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FDA</Address>
      <Comment>theChosenSeed.mEndX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FDD</Address>
      <Comment>theChosenSeed.mX = theChosenSeed.mEndX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FDF</Address>
      <Comment>theChosenSeed.mEndY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FE2</Address>
      <Comment>theChosenSeed.mTimeStartMotion = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FE5</Address>
      <Comment>theChosenSeed.mTimeEndMotion = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FE8</Address>
      <Comment>theChosenSeed.mSeedState = SEED_IN_BANK;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FEF</Address>
      <Comment>theChosenSeed.mY = theChosenSeed.mEndY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FF2</Address>
      <Comment>mSeedsInFlight--;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+84FFB</Address>
      <Comment>else if (theChosenSeed.mSeedState == SEED_FLYING_TO_CHOOSER)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85000</Address>
      <Comment>theChosenSeed.mEndX;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85003</Address>
      <Comment>theChosenSeed.mY = theChosenSeed.mEndY;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85005</Address>
      <Comment>theChosenSeed.mEndY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85008</Address>
      <Comment>theChosenSeed.mY = theChosenSeed.mEndY;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8500E</Address>
      <Comment>theChosenSeed.mTimeStartMotion = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85011</Address>
      <Comment>theChosenSeed.mTimeEndMotion = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85014</Address>
      <Comment>theChosenSeed.mSeedState = SEED_IN_CHOOSER;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8501B</Address>
      <Comment>mSeedsInFlight--;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85021</Address>
      <Comment>if (theChosenSeed.mSeedType == SEED_IMITATER)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85027</Address>
      <Comment>SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85028</Address>
      <Comment>theChosenSeed.mSeedState = SEED_PACKET_HIDDEN;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8502F</Address>
      <Comment>theChosenSeed.mImitaterType = SEED_NONE;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85032</Address>
      <Comment>UpdateImitaterButton();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85E90</Address>
      <Comment>eax是this指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85E95</Address>
      <Comment>获取theChosenSeed
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85E99</Address>
      <Comment>theChosenSeed.mSeedIndexInBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85E9D</Address>
      <Comment>获取this指针保存到esi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85E9F</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EA5</Address>
      <Comment>mBoard-&gt;mSeedBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EAB</Address>
      <Comment>theChosenSeed.mSeedIndexInBank + 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EAE</Address>
      <Comment>anIndex&lt;mBoard-&gt;mSeedBank-&gt;mNumPackets
for循环的条件
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EB2</Address>
      <Comment>[esp+24]对应anIndex
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EBC</Address>
      <Comment>循环体开始
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EC0</Address>
      <Comment>int theIndexInBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EC1</Address>
      <Comment>eax = SeedChooserScreen* this
FindSeedInBank(anIndex)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EC6</Address>
      <Comment>if (aSeedType != SEED_NONE)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85ED4</Address>
      <Comment>经常出现这种操作
imul edx,eax,0xF
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85ED6</Address>
      <Comment>mSeedChooserAge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EDC</Address>
      <Comment>数组寻址mChosenSeeds[aSeedType]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EE3</Address>
      <Comment>aChosenSeed = mChosenSeeds[aSeedType]
确切的讲应该是aChosenSeed.mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EEE</Address>
      <Comment>aChosenSeed-&gt;mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EF7</Address>
      <Comment>aChosenSeed.mStartX = aChosenSeed.mX;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EFA</Address>
      <Comment>aChosenSeed.mStartY = aChosenSeed.mY;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85EFD</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F03</Address>
      <Comment>edi = int theIndex
mBoard-&gt;GetSeedPacketPositionX(theIndex)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F0A</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F10</Address>
      <Comment>mBoard-&gt;mSeedBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F16</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F19</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mX - mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F1C</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mX - mX + mBoard-&gt;GetSeedPacketPositionX(theIndex)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F1E</Address>
      <Comment>x = mBoard-&gt;mSeedBank-&gt;mX - mX + mBoard-&gt;GetSeedPacketPositionX(theIndex);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F21</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F27</Address>
      <Comment>mBoard-&gt;mSeedBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F2D</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F30</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mY - mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F33</Address>
      <Comment>aChosenSeed.mSeedState = SEED_FLYING_TO_BANK;
这才是导致抖动bug的原因
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F3A</Address>
      <Comment>mBoard-&gt;mSeedBank-&gt;mY - mY + 8
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F3D</Address>
      <Comment>y = mBoard-&gt;mSeedBank-&gt;mY - mY + 8;
以上对应了GetSeedPositionInBank(anIndex - 1, aChosenSeed.mEndX, aChosenSeed.mEndY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F40</Address>
      <Comment>aChosenSeed.mSeedIndexInBank = anIndex - 1;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F43</Address>
      <Comment>mSeedsInFlight++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F4A</Address>
      <Comment>恢复ebx寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F4E</Address>
      <Comment>共用代码
mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F54</Address>
      <Comment>mBoard-&gt;mSeedBank
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F5A</Address>
      <Comment>anIndex++
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F60</Address>
      <Comment>判断下一轮循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F6D</Address>
      <Comment>离开循环体
mSeedChooserAge;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F73</Address>
      <Comment>theChosenSeed.mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F76</Address>
      <Comment>theChosenSeed.mTimeStartMotion = mSeedChooserAge;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F79</Address>
      <Comment>mSeedChooserAge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F7F</Address>
      <Comment>theChosenSeed.mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F82</Address>
      <Comment>mSeedChooserAge + 25
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F85</Address>
      <Comment>theChosenSeed.mTimeEndMotion = mSeedChooserAge + 25
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F8B</Address>
      <Comment>int&amp; y
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F8C</Address>
      <Comment>ecx = int theIndex
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F8F</Address>
      <Comment>ebx = int&amp; x
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F92</Address>
      <Comment>edi = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F94</Address>
      <Comment>theChosenSeed.mStartX = theChosenSeed.mX;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F97</Address>
      <Comment>theChosenSeed.mStartY = theChosenSeed.mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F9A</Address>
      <Comment>GetSeedPositionInChooser(theChosenSeed.mSeedType, theChosenSeed.mEndX, theChosenSeed.mEndY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85F9F</Address>
      <Comment>theChosenSeed.mSeedState = SEED_FLYING_TO_CHOOSER;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FA8</Address>
      <Comment>theChosenSeed.mSeedIndexInBank = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FAB</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FB4</Address>
      <Comment>mSeedsInBank--;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FBF</Address>
      <Comment>mSeedsInFlight++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FC5</Address>
      <Comment>mToolTip-&gt;mVisible = false
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FC8</Address>
      <Comment>函数展开mStartButton
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FCE</Address>
      <Comment>mToolTipSeed = SEED_NONE;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FD4</Address>
      <Comment>mStartButton-&gt;mDisabled = theDisabled;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FD7</Address>
      <Comment>edx = int theGreen
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FDC</Address>
      <Comment>int theBlue
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FDE</Address>
      <Comment>ecx = int theRed
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FE0</Address>
      <Comment>eax = Color* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FE9</Address>
      <Comment>mStartButton
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FEF</Address>
      <Comment>获取图像具体信息
暂不考虑Sexy::Color底层的问题
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FF1</Address>
      <Comment>mStartButton-&gt;mColors[GameButton::COLOR_LABEL] = Color(64, 64, 64)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+85FF4</Address>
      <Comment>接下来是结构体分多次赋值的问题
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86009</Address>
      <Comment>接下来是虚函数寻址过程
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86011</Address>
      <Comment>Sexy::SOUND_TAP
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8601C</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8601D</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8601F</Address>
      <Comment>mApp-&gt;PlaySample(Sexy::SOUND_TAP)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86021</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86150</Address>
      <Comment>该函数会在鼠标划过选卡界面时调用
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86165</Address>
      <Comment>局部变量区
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86169</Address>
      <Comment>返回地址在[esp+50]
获取SeedChooserScreen*指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8616D</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86173</Address>
      <Comment>mApp-&gt;mWidgetManager
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86179</Address>
      <Comment>mApp-&gt;mWidgetManager-&gt;mMouseIn
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86180</Address>
      <Comment>if (!mApp-&gt;mWidgetManager-&gt;mMouseIn...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86186</Address>
      <Comment>if (...!mApp-&gt;mActive)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86195</Address>
      <Comment>虚函数寻址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8619B</Address>
      <Comment>546310
ecx = SexyAppBase* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8619D</Address>
      <Comment>if (...mApp-&gt;GetDialogCount() &gt; 0...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861A5</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861AB</Address>
      <Comment>mChooseState == CHOOSE_VIEW_LAWN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861B1</Address>
      <Comment>if (...mChooseState == CHOOSE_VIEW_LAWN)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861B3</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861B9</Address>
      <Comment>mToolTip-&gt;mVisible = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861BD</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861BE</Address>
      <Comment>mToolTipSeed = SEED_NONE;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861DA</Address>
      <Comment>else if (mSeedsInFlight &lt;= 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861E7</Address>
      <Comment>eax = GameButton* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+861FC</Address>
      <Comment>mMouseVisible
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86206</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86208</Address>
      <Comment>ecx = _Out_ std::string&amp;&amp; aToolTipString
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8620C</Address>
      <Comment>Plant::GetToolTip(SEED_IMITATER)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8621C</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86222</Address>
      <Comment>edx = const std::string&amp; theLabel
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86224</Address>
      <Comment>mToolTip-&gt;SetLabel(Plant::GetToolTip(SEED_IMITATER));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8622C</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86239</Address>
      <Comment>SeedType theImitaterType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8623E</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86240</Address>
      <Comment>_Out_ std::string&amp;&amp; aNameString
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8624D</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86253</Address>
      <Comment>edx = const std::string&amp; theTitle
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86255</Address>
      <Comment>mToolTip-&gt;SetTitle(Plant::GetNameString(SEED_IMITATER));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86267</Address>
      <Comment>const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8626C</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8627D</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86283</Address>
      <Comment>edx = const std::string&amp; theWarningText
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86287</Address>
      <Comment>mToolTip-&gt;SetWarningText(_S(""));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8628C</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8629B</Address>
      <Comment>SEED_PACKET_WIDTH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862A0</Address>
      <Comment>SEED_PACKET_WIDTH - mToolTip-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862A4</Address>
      <Comment>万年不变的除以二算法
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862A6</Address>
      <Comment>mImitaterButton
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862AE</Address>
      <Comment>(SEED_PACKET_WIDTH - mToolTip-&gt;mWidth) / 2 + mImitaterButton-&gt;mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862B1</Address>
      <Comment>mToolTip-&gt;mX = (SEED_PACKET_WIDTH - mToolTip-&gt;mWidth) / 2 + mImitaterButton-&gt;mX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862B4</Address>
      <Comment>mImitaterButton
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862BA</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862C0</Address>
      <Comment>mImitaterButton-&gt;mY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862C3</Address>
      <Comment>mImitaterButton-&gt;mY - mToolTip-&gt;mHeight
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862C6</Address>
      <Comment>mToolTip-&gt;mY = mImitaterButton-&gt;mY - mToolTip-&gt;mHeight;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862C9</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862CF</Address>
      <Comment>mToolTip-&gt;mVisible = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862E8</Address>
      <Comment>mLastMouseY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862EE</Address>
      <Comment>mLastMouseX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862F4</Address>
      <Comment>int y
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862F5</Address>
      <Comment>int x
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862F6</Address>
      <Comment>esi = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862F8</Address>
      <Comment>SeedHitTest(mLastMouseX, mLastMouseY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+862FD</Address>
      <Comment>SeedType aSeedType = SeedHitTest(mLastMouseX, mLastMouseY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86302</Address>
      <Comment>if (aSeedType == SEED_NONE)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86304</Address>
      <Comment>aSeedType进入内存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8630A</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86312</Address>
      <Comment>mToolTip-&gt;mVisible = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86316</Address>
      <Comment>mToolTipSeed = SEED_NONE;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8632F</Address>
      <Comment>else if (aSeedType != mToolTipSeed)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86337</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86342</Address>
      <Comment>imul edx,edi,0x15
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86344</Address>
      <Comment>ChosenSeed&amp; aChosenSeed = mChosenSeeds[aSeedType]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8634B</Address>
      <Comment>mToolTip-&gt;mVisible = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8634F</Address>
      <Comment>SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86350</Address>
      <Comment>esi = SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86352</Address>
      <Comment>mToolTipSeed = SEED_NONE;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8635C</Address>
      <Comment>SeedNotRecommendedToPick(aSeedType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8636E</Address>
      <Comment>重点
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86374</Address>
      <Comment>eax = SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86376</Address>
      <Comment>SeedNotAllowedToPick(aSeedType)
怎么在函数表里面没有找到this参数?奇怪了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8637B</Address>
      <Comment>if (SeedNotAllowedToPick(aSeedType))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8637F</Address>
      <Comment>/*%s*/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86384</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86395</Address>
      <Comment>/*mToolTip*/
esi = ToolTipWidget* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8639B</Address>
      <Comment>edx = const std::string&amp; theWarningText
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863AD</Address>
      <Comment>ebx = SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863AF</Address>
      <Comment>eax = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863B1</Address>
      <Comment>SeedNotAllowedDuringTrial(aSeedType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863B6</Address>
      <Comment>else if (SeedNotAllowedDuringTrial(aSeedType))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863BA</Address>
      <Comment>/*%s*/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863BF</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863D6</Address>
      <Comment>aChosenSeed.mSeedState == SEED_IN_BANK
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863DC</Address>
      <Comment>aChosenSeed.mCrazyDavePicked
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863E2</Address>
      <Comment>/*%s*/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863E7</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+863FE</Address>
      <Comment>else if (aRecFlags != 0U)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86400</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86406</Address>
      <Comment>if (TestBit(aRecFlags, NOT_RECOMMENDED_NOCTURNAL))
夜间植物检验
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8640A</Address>
      <Comment>/*%s*/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86432</Address>
      <Comment>/*%s*/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86444</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8644A</Address>
      <Comment>edx = const std::string&amp; theWarningText
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8644E</Address>
      <Comment>mToolTip-&gt;SetWarningText(_S(""));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8645B</Address>
      <Comment>共用代码
ecx = std::string* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86464</Address>
      <Comment>if (aSeedType == SEED_IMITATER)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86470</Address>
      <Comment>SeedType theImitaterType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86475</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86476</Address>
      <Comment>_Out_ std::string&amp;&amp; aNameString
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86477</Address>
      <Comment>Plant::GetNameString(aSeedType, aChosenSeed.mImitaterType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86487</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8648D</Address>
      <Comment>edx = const std::string&amp; theTitle
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8648F</Address>
      <Comment>mToolTip-&gt;SetTitle(Plant::GetNameString(aSeedType, aChosenSeed.mImitaterType));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86494</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864A5</Address>
      <Comment>aChosenSeed.mImitaterType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864A8</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864A9</Address>
      <Comment>ecx = _Out_ std::string&amp;&amp; aToolTipString
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864AD</Address>
      <Comment>Plant::GetToolTip(aChosenSeed.mImitaterType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864BD</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864C3</Address>
      <Comment>edx = const std::string&amp; theLabel
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864C5</Address>
      <Comment>mToolTip-&gt;SetLabel(Plant::GetToolTip(aChosenSeed.mImitaterType));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864CA</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864D5</Address>
      <Comment>SeedType theImitaterType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864DB</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864DC</Address>
      <Comment>_Out_ std::string&amp;&amp; aNameString)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864DD</Address>
      <Comment>Plant::GetNameString(aSeedType, SEED_NONE)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864ED</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864F3</Address>
      <Comment>edx = const std::string&amp; theTitle
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+864FA</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8650B</Address>
      <Comment>SeedType theSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8650C</Address>
      <Comment>ecx = _Out_ std::string&amp;&amp; aToolTipString
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86520</Address>
      <Comment>esi = ToolTipWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86526</Address>
      <Comment>edx = const std::string&amp; theLabel
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86528</Address>
      <Comment>mToolTip-&gt;SetLabel(Plant::GetToolTip(aSeedType));
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8652D</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8653A</Address>
      <Comment>共用代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86540</Address>
      <Comment>edi = int theIndex
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86547</Address>
      <Comment>int&amp; y
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8654C</Address>
      <Comment>int&amp; x
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8654D</Address>
      <Comment>esi = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8654F</Address>
      <Comment>GetSeedPositionInBank(aChosenSeed.mSeedIndexInBank, aSeedX, aSeedY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8655A</Address>
      <Comment>ecx = int theIndex
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8655C</Address>
      <Comment>int&amp; x

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86561</Address>
      <Comment>edi = SeedChooserScreen* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86563</Address>
      <Comment>GetSeedPositionInChooser(aSeedType, aSeedX, aSeedY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86568</Address>
      <Comment>mToolTip

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8656E</Address>
      <Comment>mToolTip-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86571</Address>
      <Comment>SEED_PACKET_WIDTH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86576</Address>
      <Comment>SEED_PACKET_WIDTH - mToolTip-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86579</Address>
      <Comment>仍然是补码除以二算法
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86581</Address>
      <Comment>BOARD_WIDTH
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86586</Address>
      <Comment>BOARD_WIDTH - mToolTip-&gt;mWidth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+8658A</Address>
      <Comment>此乃ClampInt函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86596</Address>
      <Comment>mToolTip-&gt;mX = ClampInt((SEED_PACKET_WIDTH - mToolTip-&gt;mWidth) / 2 + aSeedX, 0, BOARD_WIDTH - mToolTip-&gt;mWidth);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86599</Address>
      <Comment>aSeedY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865A3</Address>
      <Comment>aSeedY+70
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865A6</Address>
      <Comment>mToolTip-&gt;mY = aSeedY + 70;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865A9</Address>
      <Comment>mToolTip
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865AF</Address>
      <Comment>aSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865B5</Address>
      <Comment>mToolTip-&gt;mVisible = true;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+865BA</Address>
      <Comment>mToolTipSeed = aSeedType;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86CE1</Address>
      <Comment>SeedType aSeedType = SEED_PEASHOOTER;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86CE9</Address>
      <Comment>循环计数器的增量
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86CEE</Address>
      <Comment>废话
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86D05</Address>
      <Comment>aSeedType++
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+86D0A</Address>
      <Comment>esi是aSeedType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D10</Address>
      <Comment>巨人体型很大,函数也很大
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D19</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D1A</Address>
      <Comment>获取僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D1D</Address>
      <Comment>僵尸状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D20</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_GARGANTUAR_SMASHING
是否处于巨人砸的状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D2B</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D33</Address>
      <Comment>获取动画对象
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D39</Address>
      <Comment>mBodyReanimID
接下来又是ReanimationGet的函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D4D</Address>
      <Comment>ecx = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D4F</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D50</Address>
      <Comment>float theEventTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D53</Address>
      <Comment>aBodyReanim保存到内存
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D57</Address>
      <Comment>aBodyReanim-&gt;ShouldTriggerTimedEvent(0.64f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D5C</Address>
      <Comment>if (aBodyReanim-&gt;ShouldTriggerTimedEvent(0.64f))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D64</Address>
      <Comment>ZombieAttackType theAttackType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D66</Address>
      <Comment>Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D67</Address>
      <Comment>FindPlantTarget(ZombieAttackType::ATTACKTYPE_CHEW)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D6C</Address>
      <Comment>目标植物保存至edi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D6E</Address>
      <Comment>if (FindPlantTarget(ZombieAttackType::ATTACKTYPE_CHEW))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D72</Address>
      <Comment>if (aPlant-&gt;mSeedType == SeedType::SEED_SPIKEROCK)
是否是钢地刺?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D78</Address>
      <Comment>int theDamage
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D7A</Address>
      <Comment>eax = unsigned int theDamageFlags
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D7F</Address>
      <Comment>esi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D81</Address>
      <Comment>TakeDamage(20, 32U);
砸钢地刺会使得自己受伤
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D86</Address>
      <Comment>esi = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D88</Address>
      <Comment>aPlant-&gt;SpikeRockTakeDamage();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D8D</Address>
      <Comment>if (aPlant-&gt;mPlantHealth &lt;= 0)
如果钢地刺已经被砸到血量低于零了?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D93</Address>
      <Comment>植物行数

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D96</Address>
      <Comment>植物列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D99</Address>
      <Comment>ZombieAttackType theAttackType
/*ZombieAttackType::ATTACKTYPE_CHEW*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D9B</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D9C</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126D9F</Address>
      <Comment>如果植物类型不是钢地刺,会跳转到这里
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DA5</Address>
      <Comment>/*ZombieAttackType::ATTACKTYPE_CHEW*/
ZombieAttackType theAttackType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DA7</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DA8</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DA9</Address>
      <Comment>edi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DAB</Address>
      <Comment>SquishAllInSquare(aPlant-&gt;mPlantCol, aPlant-&gt;mRow, ZombieAttackType::ATTACKTYPE_CHEW);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DB0</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DB2</Address>
      <Comment>mApp-&gt;mGameMode
接下来又是mApp-&gt;IsScaryPotterLevel()的函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DB8</Address>
      <Comment>if (mGameMode &gt;= GameMode::GAMEMODE_SCARY_POTTER_1...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DBD</Address>
      <Comment>if (...mGameMode &lt;= GameMode::GAMEMODE_SCARY_POTTER_9)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DC2</Address>
      <Comment>mGameMode == GameMode::GAMEMODE_ADVENTURE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DC6</Address>
      <Comment>获取存档
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DCC</Address>
      <Comment>存档关卡是不是4-5?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DD2</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DD5</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DD8</Address>
      <Comment>强转
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DDD</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DE0</Address>
      <Comment>edi = int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DE2</Address>
      <Comment>强转
同时作为"call 41C4C0"的实参
eax = int theX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DE7</Address>
      <Comment>ecx = Board* this

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DE9</Address>
      <Comment>mBoard-&gt;PixelToGridX(mPosX, mPosY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DEE</Address>
      <Comment>edi = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DF1</Address>
      <Comment>GridItemType theGridItemType
/*GridItemType::GRIDITEM_SCARY_POT*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DF3</Address>
      <Comment>ebx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DF5</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DF7</Address>
      <Comment>在砸罐子关卡中,巨人会砸扁附近的罐子
返回值:aScaryPot
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126DFC</Address>
      <Comment>if (aScaryPot)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E00</Address>
      <Comment>僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E03</Address>
      <Comment>GridItem* theScaryPot
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E04</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E07</Address>
      <Comment>mBoard-&gt;mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E0D</Address>
      <Comment>Challeng* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E0E</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;ScaryPotterOpenPot(aScaryPot);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E13</Address>
      <Comment>僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E16</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E18</Address>
      <Comment>mApp-&gt;IsIZombieLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E1D</Address>
      <Comment>if (mApp-&gt;IsIZombieLevel())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E21</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E24</Address>
      <Comment>mBoard-&gt;mChallenge

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E2A</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E2B</Address>
      <Comment>eax = Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E2D</Address>
      <Comment>aBrain = mBoard-&gt;mChallenge-&gt;IZombieGetBrainTarget(this)

同时也是"call 42BA30"的实参
eax = Griditem* theBrain

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E32</Address>
      <Comment>if (aBrain)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E36</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E39</Address>
      <Comment>mBoard-&gt;mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E3F</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E40</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;IZombieSquishBrain(aBrain)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E45</Address>
      <Comment>日常LawnApp::PlayFoley函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E75</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E76</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E82</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E89</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E8A</Address>
      <Comment>eax = FoleyType theFoleyType
/*FoleyType::FOLEY_THUMP*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E8F</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E92</Address>
      <Comment>ecx = TodFoley* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E94</Address>
      <Comment>TodFoley::PlayFoleyPitch(float thePitch, eax = FoleyType theFoleyType, ecx = TodFoley* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E99</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126E9C</Address>
      <Comment>从内存中获取aBodyReanim
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EA0</Address>
      <Comment>mShakeCounter = 12;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EAA</Address>
      <Comment>mShakeAmountX = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EB4</Address>
      <Comment>mShakeAmountY = 3
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EBE</Address>
      <Comment>if (aBodyReanim-&gt;mLoopCount &gt; 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EC8</Address>
      <Comment>esi = int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126ECD</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126ECF</Address>
      <Comment>mZombiePhase = ZombiePhase::PHASE_ZOMBIE_NORMAL;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126ED6</Address>
      <Comment>StartWalkAnim(20);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EDB</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EE4</Address>
      <Comment>是否处于扔小鬼的状态?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EE7</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EEA</Address>
      <Comment>mPosX-360.0
%s
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EF0</Address>
      <Comment>float aThrowingDistance = mPosX - 360.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126EFA</Address>
      <Comment>if (mZombiePhase == ZombiePhase::PHASE_GARGANTUAR_THROWING)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F02</Address>
      <Comment>接下来又是ReanimationGet
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F1C</Address>
      <Comment>ecx = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F1E</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F1F</Address>
      <Comment>float theEventTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F22</Address>
      <Comment>Reanimation* aBodyReanim = mApp-&gt;ReanimationGet(mBodyReanimID);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F26</Address>
      <Comment>aBodyReanim-&gt;ShouldTriggerTimedEvent(0.74f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F2B</Address>
      <Comment>if (aBodyReanim-&gt;ShouldTriggerTimedEvent(0.74f))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F33</Address>
      <Comment>/*RENDER_GROUP_HIDDEN*/
int theRenderGroup
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F35</Address>
      <Comment>%s
const char* theTrackPrefix
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F3A</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F3C</Address>
      <Comment>mHasObject = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F43</Address>
      <Comment>ReanimShowPrefix("Zombie_imp", RENDER_GROUP_HIDDEN);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F48</Address>
      <Comment>%s
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F4D</Address>
      <Comment>ecx = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F4F</Address>
      <Comment>ReanimShowTrack("Zombie_gargantuar_whiterope", RENDER_GROUP_HIDDEN);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F54</Address>
      <Comment>LawnApp::PlayFoley函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F84</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F85</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F98</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F99</Address>
      <Comment>eax = FoleyType theFoleyType
/*FoleyType::FOLEY_SWING*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126F9E</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FA1</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FAA</Address>
      <Comment>废话指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FAC</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FAF</Address>
      <Comment>mFromWave
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FB2</Address>
      <Comment>ZombieType theZombieType
/*ZombieType::ZOMBIE_IMP*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FB4</Address>
      <Comment>eax = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FB6</Address>
      <Comment>PickRowForNewZombie(theZombieType)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FBB</Address>
      <Comment>将获取到的随机行数保存到[esp+18]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FBF</Address>
      <Comment>获取僵尸数量上限,保存到eax

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FC8</Address>
      <Comment>比较当前僵尸数与僵尸数量上限-1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FCE</Address>
      <Comment>如果僵尸数量超标,那就返回
(??难道巨人还不会丢小鬼了?)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FD4</Address>
      <Comment>int range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FDE</Address>
      <Comment>Rand(5)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FE3</Address>
      <Comment>if (!Rand(5))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FE7</Address>
      <Comment>[esp+10]用于保存theVariant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FEC</Address>
      <Comment>esi = DataArray&lt;Zombie&gt;* this
此处是通过加法指令来实现地址加法和偏移寻址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FF2</Address>
      <Comment>mZombies.DataArrayAlloc()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FFB</Address>
      <Comment>int theFromWave
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FFC</Address>
      <Comment>Zombie* theParentZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FFE</Address>
      <Comment>bool theVariant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+126FFF</Address>
      <Comment>获取到的僵尸存放在esi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127001</Address>
      <Comment>eax = int theRow
注意刚刚进行了三次push,所以应该对应堆栈平衡状态下的[esp+18]
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127005</Address>
      <Comment>ZombieType theZombieType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127007</Address>
      <Comment>Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127008</Address>
      <Comment>aZombie-&gt;ZombieInitialize(theRow, theZombieType, aVariant, nullptr, theFromWave)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12700D</Address>
      <Comment>if (aZombieImp)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127015</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127024</Address>
      <Comment>float aMinThrowDistance = 40.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127028</Address>
      <Comment>mBoard-&gt;mBackground == BackgroundType::BACKGROUND_5_ROOF
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12702D</Address>
      <Comment>mBoard-&gt;mBackground == BackgroundType::BACKGROUND_6_BOSS
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12703C</Address>
      <Comment>aThrowingDistance -= 180.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127046</Address>
      <Comment>aMinThrowDistance = -140.0f;
屋顶巨人肾虚的原理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12704A</Address>
      <Comment>aThrowingDistance
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12704E</Address>
      <Comment>aMinThrowingDistance
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127052</Address>
      <Comment>if (aThrowingDistance &lt; aMinThrowDistance)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127078</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127081</Address>
      <Comment>float theMax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127087</Address>
      <Comment>float theMin
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12708A</Address>
      <Comment>RandRangeFloat(0.0f, 100.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12708F</Address>
      <Comment>aThrowingDistance -= RandRangeFloat(0.0f, 100.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127093</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127096</Address>
      <Comment>aThrowingDistance -= RandRangeFloat(0.0f, 100.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12709C</Address>
      <Comment>废话指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12709E</Address>
      <Comment>回忆一下ebx是巨人(不是小鬼)僵尸指针
mPosX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270A1</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270A9</Address>
      <Comment>aZombieImp-&gt;mPosX = mPosX - 133.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270AC</Address>
      <Comment>行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270AF</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270B0</Address>
      <Comment>GetPosYBasedOnRow(mRow)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270B5</Address>
      <Comment>aZombieImp-&gt;mPosY = GetPosYBasedOnRow(mRow);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270B8</Address>
      <Comment>获取巨人所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270C1</Address>
      <Comment>zombieImp-&gt;SetRow(mRow);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270C4</Address>
      <Comment>MakeRenderOrder再次函数展开
theRow * (int)RenderLayer::RENDER_LAYER_ROW_OFFSET
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270CA</Address>
      <Comment>RenderLayer::RENDER_LAYER_ZOMBIE+4

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270CF</Address>
      <Comment>mRenderOrder = Board::MakeRenderOrder(RenderLayer::RENDER_LAYER_ZOMBIE, mRow, 4);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270D2</Address>
      <Comment>aZombieImp-&gt;mVariant = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270D6</Address>
      <Comment>获取巨人图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270D9</Address>
      <Comment>mRenderOrder+1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270DC</Address>
      <Comment>aZombieImp-&gt;mAltitude = 88.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270E2</Address>
      <Comment>aZombieImp-&gt;mRenderOrder = mRenderOrder + 1;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270EB</Address>
      <Comment>aZombieImp-&gt;mZombiePhase = ZombiePhase::PHASE_IMP_GETTING_THROWN
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270F2</Address>
      <Comment>aZombieImp-&gt;mVelX = 3.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270F5</Address>
      <Comment>mChilledCounter
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270FB</Address>
      <Comment>aThrowingDistance
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1270FF</Address>
      <Comment>占位,见52712E
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127108</Address>
      <Comment>aZombieImp-&gt;mChilledCounter = mChilledCounter;
减速巨人丢出的小鬼也应该处于减速状态
反之亦然
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127122</Address>
      <Comment>aZombieImp-&gt;mVelZ = 0.5f * (aThrowingDistance / aZombieImp-&gt;mVelX) * THOWN_ZOMBIE_GRAVITY;
以上操作是典型的使用栈计算表达式的过程
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12712E</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127131</Address>
      <Comment>int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127133</Address>
      <Comment>ReanimLoopType theLoopType
/*ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127135</Address>
      <Comment>/*%s*/
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12713A</Address>
      <Comment>参考源码:(参数类型有出入)
aZombieImp-&gt;PlayZombieReanim("anim_thrown", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 0, 18.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12713F</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127141</Address>
      <Comment>aZombieImp-&gt;UpdateReanim();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127146</Address>
      <Comment>mApp-&gt;PlayFoley函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127176</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127177</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127183</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12718A</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12718B</Address>
      <Comment>eax = FoleyType* theFoleyType
/*FoleyType::FOLEY_IMP*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127190</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127193</Address>
      <Comment>ecx = TodFoley* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12719A</Address>
      <Comment>精准堆栈,aBodyReanim
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12719E</Address>
      <Comment>if (aBodyReanim-&gt;mLoopCount &gt; 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271A8</Address>
      <Comment>esi = int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271AD</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271AF</Address>
      <Comment>mZombiePhase = ZombiePhase::PHASE_ZOMBIE_NORMAL;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271B6</Address>
      <Comment>StartWalkAnim(20);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271BB</Address>
      <Comment>日常返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271C4</Address>
      <Comment>如果没有在扔小鬼,就跳转到这里
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271CB</Address>
      <Comment>mIceTrapCounter &gt; 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271D1</Address>
      <Comment>mButteredCounter &gt; 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271D8</Address>
      <Comment>条件跳转到返回,下同

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271DE</Address>
      <Comment>!mHasHead
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271EB</Address>
      <Comment>if (mHasObject...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271F4</Address>
      <Comment>mBodyMaxHealth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271FD</Address>
      <Comment>mBodyMaxHealth/2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1271FF</Address>
      <Comment>mBodyHealth &lt; mBodyMaxHealth / 2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127211</Address>
      <Comment>aThrowingDistance &gt; 40.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127216</Address>
      <Comment>虽然看不懂浮点标志位.但是应该明白:
在jxxx(即使是看不懂的jp)之后就是分支体或循环体
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12721E</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12721F</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127222</Address>
      <Comment>int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127224</Address>
      <Comment>ReanimLoopType theLoopType
/*ReanimationLoopType::PLAY_ONCE_AND_HOLD*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127226</Address>
      <Comment>/*%s*/
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12722B</Address>
      <Comment>edi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12722D</Address>
      <Comment>mZombiePhase = ZombiePhase::PHASE_GARGANTUAR_THROWING;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127234</Address>
      <Comment>再次注意与参考源码参数类型有出入
PlayZombieReanim("anim_throw", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 24.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127239</Address>
      <Comment>返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127242</Address>
      <Comment>ZombieAttackType theAttackType
/*ZombieAttackType::ATTACKTYPE_CHEW*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127244</Address>
      <Comment>Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127245</Address>
      <Comment>FindPlantTarget(ZombieAttackType::ATTACKTYPE_CHEW)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12724A</Address>
      <Comment>if (FindPlantTarget(ZombieAttackType::ATTACKTYPE_CHEW))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12724E</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127250</Address>
      <Comment>mApp-&gt;IsScaryPotterLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127255</Address>
      <Comment>if (mApp-&gt;IsScaryPotterLevel())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127259</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12725C</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12725F</Address>
      <Comment>强转,(int)mPosY
注意强转后结果存放在eax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127264</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127267</Address>
      <Comment>edi = int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127269</Address>
      <Comment>强转,(int)mPosX

eax = int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12726E</Address>
      <Comment>ecx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127270</Address>
      <Comment>mBoard-&gt;PixelToGridX(mPosX, mPosY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127275</Address>
      <Comment>edi = int theGridY
行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127278</Address>
      <Comment>GridItemType theGridItemType
/*GridItemType::GRIDITEM_SCARY_POT*/

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12727A</Address>
      <Comment>ebx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12727C</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12727E</Address>
      <Comment>mBoard-&gt;GetScaryPotAt(aGridX, mRow)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127283</Address>
      <Comment>if (mBoard-&gt;GetScaryPotAt(aGridX, mRow))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127287</Address>
      <Comment>再次精准堆栈,恢复ebx为僵尸指针
因为刚刚修改过ebx的值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12728C</Address>
      <Comment>mApp-&gt;IsScaryPotterLevel()判断不成立则跳转到这里
eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12728E</Address>
      <Comment>mApp-&gt;IsIZombieLevel()

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127293</Address>
      <Comment>if (mApp-&gt;IsIZombieLevel())
//应该是else if
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127295</Address>
      <Comment>如果不是在我是僵尸关卡,那就无需再发动锤击了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127297</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12729A</Address>
      <Comment>mBoard-&gt;mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272A0</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272A1</Address>
      <Comment>eax = Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272A3</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;IZombieGetBrainTarget(this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272A8</Address>
      <Comment>if (mBoard-&gt;mChallenge-&gt;IZombieGetBrainTarget(this))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272AA</Address>
      <Comment>如果找不到可砸的脑子,也返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272AC</Address>
      <Comment>这是巨人发动锤击的代码
eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272AE</Address>
      <Comment>ZombiePhase::PHASE_GARGANTUAR_SMASHING
esi = FoleyType theFoleyType

需要设置僵尸状态,同时对音效传参
这两者数值相同,所以就共用了


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272B3</Address>
      <Comment>mZombiePhase = ZombiePhase::PHASE_GARGANTUAR_SMASHING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272B6</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_LOW_GROAN)
举锤≠砸下
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272C1</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272C2</Address>
      <Comment>float theAnimTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272C5</Address>
      <Comment>int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272C7</Address>
      <Comment>ReanimLoopType theLoopType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272C9</Address>
      <Comment>/*%s*/
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272CE</Address>
      <Comment>edi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272D0</Address>
      <Comment>有出入的参考源码:
PlayZombieReanim("anim_smash", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 16.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1272D5</Address>
      <Comment>恢复易变寄存器,返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273D0</Address>
      <Comment>现在开始分析代码!
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273D3</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273D4</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273D5</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273D8</Address>
      <Comment>判断是否处于濒死状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273DF</Address>
      <Comment>濒死则跳转(到返回)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273E5</Address>
      <Comment>僵尸的属性倒计时赋值给eax
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273E8</Address>
      <Comment>十进制35,判断是否到了发射子弹的时间
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273EB</Address>
      <Comment>如果不发射子弹,则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273ED</Address>
      <Comment>执行完毕之后,eax=基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273EF</Address>
      <Comment>获取头部动画(如果参考源码,这里进行了编译优化)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273F5</Address>
      <Comment>找到动画信息
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273FB</Address>
      <Comment>粒子系统数量上限(人话:子弹上限)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1273FE</Address>
      <Comment>这个位运算是为了把动画信息限定在一个范围内
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12740F</Address>
      <Comment>StartBlend()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12744B</Address>
      <Comment>以上全是在传参,对应函数调用:
aHeadReanim-&gt;PlayReanim("anim_shooting", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 35.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127450</Address>
      <Comment>返回了:35秒只是播放射击动画,不涉及实际产生子弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127457</Address>
      <Comment>由于eax是属性倒计时,所以这里在判断是否处于添加子弹阶段
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127459</Address>
      <Comment>如果不发射子弹,则跳走到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12745F</Address>
      <Comment>接下来一大堆都不用看,功能类似
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127511</Address>
      <Comment>int aTrackIndex = aBodyReanim-&gt;FindTrackIndex("anim_head1");
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127555</Address>
      <Comment>aBodyReanim-&gt;GetCurrentTransform(aTrackIndex, &amp;aTransform);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12755A</Address>
      <Comment>加载横坐标
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12755D</Address>
      <Comment>将edx赋值为所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127564</Address>
      <Comment>将eax赋值为图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127567</Address>
      <Comment>ProjectileType theProjectileType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127569</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127570</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127599</Address>
      <Comment>int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12759F</Address>
      <Comment>int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275A0</Address>
      <Comment>eax = Board*
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275A3</Address>
      <Comment>"Board::AddProjectile
(ProjectileType theProjectileType, int theRow, int theRenderOrder, int theY, int theX, eax = Board* this)"
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275A8</Address>
      <Comment>子弹方向设置
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275AF</Address>
      <Comment>重制属性倒计时
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275C0</Address>
      <Comment>僵尸指针:edi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275C3</Address>
      <Comment>栈对齐
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275C9</Address>
      <Comment>同理,判断有没有濒死
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275D0</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275D1</Address>
      <Comment>保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275D2</Address>
      <Comment>若濒死则跳转到返回

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275D8</Address>
      <Comment>属性倒计时
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275DC</Address>
      <Comment>若倒计时不为零则跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275E4</Address>
      <Comment>学习浮点数指令之后应该重新分析代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275E6</Address>
      <Comment>if (!mMuteSoundsForCutscene)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275EF</Address>
      <Comment>%s
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275F9</Address>
      <Comment>if (aFoleyParams-&gt;mPitchRange != 0.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1275FF</Address>
      <Comment>mApp-&gt;mSoundSystem
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12760C</Address>
      <Comment>aFoleyParams-&gt;mPitchRange
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127612</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127613</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127616</Address>
      <Comment>Sexy::Rand(aFoleyParams-&gt;mPitchRange)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12761B</Address>
      <Comment>aPitch = Sexy::Rand(aFoleyParams-&gt;mPitchRange);  // 在范围内随机选取一个音高
此处[esp+10]对应aPitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12761F</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127622</Address>
      <Comment>由于处于堆栈不同阶段
这里的[esp+0C]仍然对应aPitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127626</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127627</Address>
      <Comment>eax = FoleyType theFoleyType
/*FoleyType::FOLEY_JALAPENO_IGNITE*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12762C</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12762F</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127631</Address>
      <Comment>PlayFoleyPitch(theFoleyType, aPitch);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127636</Address>
      <Comment>再次函数展开,展开前:
mApp-&gt;PlayFoley(FoleyType::FOLEY_JUICY);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127666</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127667</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127673</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12767A</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12767B</Address>
      <Comment>/*FoleyType::FOLEY_JUICY*/
eax = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127680</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127683</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12768C</Address>
      <Comment>弱智的代码混淆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12768E</Address>
      <Comment>获取僵尸所在行
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127691</Address>
      <Comment>ebx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127694</Address>
      <Comment>int theRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127695</Address>
      <Comment>Board::DoFwoosh(int theRow, ebx = Board* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12769A</Address>
      <Comment>将eax赋值为mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12769D</Address>
      <Comment>让画面不再正常,即mShakeCounter = 12
此处进行了函数展开的编译优化
原型:mBoard-&gt;ShakeBoard(3, -4);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276A7</Address>
      <Comment>mShakeAmountX = 3;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276B1</Address>
      <Comment>mShakeAmountY = -4;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276BB</Address>
      <Comment>edx = Board* this
烧植物开始-----------
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276BE</Address>
      <Comment>esi = Plant*&amp; thePlant
必须注意到,C++引用的底层仍然是指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276C2</Address>
      <Comment>Plant* aPlant = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276CA</Address>
      <Comment>mBoard-&gt;IteratePlants(aPlant)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276CF</Address>
      <Comment>判断是否遍历到下一个植物
while (mBoard-&gt;IteratePlants(aPlant))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276D1</Address>
      <Comment>若遍历失败,则跳走到辣椒僵尸死亡

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276D3</Address>
      <Comment>接下来就应该是遍历成功,即获取到植物的处理逻辑了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276E0</Address>
      <Comment>遍历成功的处理逻辑::
获取僵尸所在行数,存放在ecx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276E3</Address>
      <Comment>将植物指针存放在eax
理解这一点要求必须能够理解"引用的底层是指针"
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276E7</Address>
      <Comment>比较植物和僵尸所在行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276EA</Address>
      <Comment>若不处于同一行则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276EC</Address>
      <Comment>判断植物是不是倭瓜,因为需要单独处理
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276F0</Address>
      <Comment>如果不是倭瓜则跳走
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276F2</Address>
      <Comment>将ecx赋值为植物状态,注意植物肯定是倭瓜
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276F5</Address>
      <Comment>倭瓜是否处于跳起状态呢?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276F8</Address>
      <Comment>倭瓜在跳起时是无敌的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276FA</Address>
      <Comment>倭瓜下砸也是无敌的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1276FF</Address>
      <Comment>倭瓜扁仍然是无敌的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127704</Address>
      <Comment>如果植物不处于无敌帧那就到这里
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12770B</Address>
      <Comment>如果植物已经被压扁了也就不需要再处理了(禁止鞭尸)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12770D</Address>
      <Comment>同上,如果植物已经被蹦极抱走了也不能鞭尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127716</Address>
      <Comment>植物是否消失?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127722</Address>
      <Comment>被吃掉的植物数更新
在5276D3处已经设置了ebx为1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127729</Address>
      <Comment>aPlant-&gt;Die()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12772E</Address>
      <Comment>如果发现植物和僵尸不处于同一行,会直接跳转到这里
如果它们处于同一行也会顺序执行到这里的指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127731</Address>
      <Comment>再次调用mBoard-&gt;IteratePlants(aPlant)
然后进行判断,也急速进入下一层循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12773C</Address>
      <Comment>烧植物结束---------
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12773E</Address>
      <Comment>这就是遍历失败或者遍历结束之后发生的事情:辣椒僵尸死亡
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127740</Address>
      <Comment>DieNoLoot()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127753</Address>
      <Comment>老规矩,以下四条指令全是保存易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127757</Address>
      <Comment>将代表僵尸指针的赋值给edi,虽然edi本来就是僵尸指针了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127760</Address>
      <Comment>如果僵尸已经濒死,那就跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127766</Address>
      <Comment>把eax赋值为属性倒计时
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12776C</Address>
      <Comment>属性倒计时为100时,播放射击动画
本条指令:如果不是100,则跳走

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12776E</Address>
      <Comment>设置eax为基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127770</Address>
      <Comment>设置edi为头部动画贴图ID
mSpecialHeadReanimID

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127776</Address>
      <Comment>获取动画信息,并将指针保存到ecx
mEffectSystem
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12777C</Address>
      <Comment>获取粒子系统上限
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12777F</Address>
      <Comment>保留edi低16位
(unsigned int)theReanimationID
个人经验:mov edi,26

theReanimationID是形参,
实参是aSpecialHeadReanimID



</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127785</Address>
      <Comment>根据经验判断,这等同于mov esi,BE

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127788</Address>
      <Comment>结果是17C0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12778B</Address>
      <Comment>个人推测:[edx]是基址,esi是偏移量
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12778D</Address>
      <Comment>int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12778F</Address>
      <Comment>Reanimation* reanimation
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127790</Address>
      <Comment>原来的函数调用:aHeadReanim-&gt;PlayReanim("anim_shooting", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 38.0f);
此处进行了函数展开
StartBlend()
虽然保存了esi寄存器,但是它不会改变esi的值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127795</Address>
      <Comment>(38.00)
将存储器中的实型压栈
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12779B</Address>
      <Comment>mAnimRate = theAnimRate;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277A1</Address>
      <Comment>0.0压入浮点寄存器栈

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277A3</Address>
      <Comment>int&amp; theFrameCount
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277A4</Address>
      <Comment>mLoopCount = 0;
动画循环率
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277A7</Address>
      <Comment>从第几帧开始
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277B0</Address>
      <Comment>int&amp; theFrameCount
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277B1</Address>
      <Comment>("anim_shooting")
edx = const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277B6</Address>
      <Comment>mLastFrameTime = -1.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277BC</Address>
      <Comment>eax = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277CC</Address>
      <Comment>再次进行函数展开
Reanimation::GetFramesForLayer(int&amp; theFrameCount, int&amp; theFrameStart, edx = const char* theTrackName, eax = Reanimation* this)

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277D9</Address>
      <Comment>通过多次比较,判断是否到了射击时间
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277EF</Address>
      <Comment>跳转到返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277F5</Address>
      <Comment>如果属性倒计时等于零,那就要做接下来的事情
在参考源码中属性为零的分支在后面,但是此处属性为零的分支更靠前
基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1277FD</Address>
      <Comment>mEffectSystem
动画信息
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127803</Address>
      <Comment>ecx没有实际含义
因为接下来要进行浮点数传参,所以仅仅只是占个位置而已
换成sub esp,4也可以
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127804</Address>
      <Comment>??
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127807</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12781B</Address>
      <Comment>获取动画对象
esi = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12781D</Address>
      <Comment>ReanimLoopType theLoopType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12781F</Address>
      <Comment>("anim_head_idle")
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127824</Address>
      <Comment>eax = int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127829</Address>
      <Comment>aHeadReanim-&gt;PlayReanim("anim_head_idle", ReanimLoopType::REANIM_PLAY_ONCE_AND_HOLD, 20, 15.0f);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12782E</Address>
      <Comment>重置属性倒计时
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12783D</Address>
      <Comment>创建子弹开始
eax被设置为基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127841</Address>
      <Comment>mMuteSoundsForCutscene
解释一下:PlayFoley被进行了函数展开:
if (!mMuteSoundsForCutscene)
{
	mSoundSystem-&gt;PlayFoley(theFoleyType);
}
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12784A</Address>
      <Comment>(69FAD0)
FoleyParams* gFoleyParamArray;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127850</Address>
      <Comment>某个float型局部变量被设置为0
破案:这个局部变量是aPitch


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127854</Address>
      <Comment>两层函数展开
展开到了void TodFoley::PlayFoley(FoleyType theFoleyType)函数体内部

if (aFoleyParams-&gt;mPitchRange != 0.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12785A</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127862</Address>
      <Comment>获取浮点标志C2和C3的值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127867</Address>
      <Comment>aFoleyParams-&gt;mPitchRange
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12786D</Address>
      <Comment>浮点数传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12786E</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127871</Address>
      <Comment>st(0) = Sexy::Rand(aFoleyParams-&gt;mPitchRange)
浮点数函数通过st(0)返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127876</Address>
      <Comment>aPitch = st(0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12787A</Address>
      <Comment>Sexy::Rand可能是一个_cdecl(本来就是,因为是全局函数而非方法)
所以需要调用者平衡堆栈
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12787D</Address>
      <Comment>加载aPitch用于传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127881</Address>
      <Comment>浮点传参占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127882</Address>
      <Comment>eax = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127887</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12788A</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12788C</Address>
      <Comment>PlayFoleyPitch(theFoleyType, aPitch);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127893</Address>
      <Comment>极其弱智的代码混淆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127895</Address>
      <Comment>edx被赋值为基址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127897</Address>
      <Comment>获取动画信息,保存在eax中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12789D</Address>
      <Comment>粒子上限
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278A0</Address>
      <Comment>将僵尸动画编号保存至eax中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278AB</Address>
      <Comment>类似于豌豆僵尸的[edi+edi*4],虽然我也不知道具体含义
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278B3</Address>
      <Comment>("anim_head1")
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278B8</Address>
      <Comment>ebx = Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278BA</Address>
      <Comment>int aTrackIndex = aBodyReanim-&gt;FindTrackIndex("anim_head1");
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278BF</Address>
      <Comment>(-10000.00)
这是一个全局常量
constexpr const float DEFAULT_FIELD_PLACEHOLDER = -10000.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278C5</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278C9</Address>
      <Comment>ebx = int theTrackIndex
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278CB</Address>
      <Comment>float 某局部变量 = -10000.00f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278CF</Address>
      <Comment>寄存器清零用于赋值
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278D1</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278D5</Address>
      <Comment>int 某局部变量 = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278D9</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278DD</Address>
      <Comment>int 某局部变量 = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278E1</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278E5</Address>
      <Comment>Reanimation* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278E6</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278EA</Address>
      <Comment>eax = ReanimatorTransform* theTransformCurrent

说明:这就可以解释为什么要进行那么多赋值操作了,因为这里定义了一个对象:
ReanimatorTransform aTransform;
对象创建在栈区,所以需要好几条指令进行数据初始化(毕竟对象占用内存很大)

实际上应该不是局部变量,而是对象的属性
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278EE</Address>
      <Comment>float 某局部变量 = -10000.00f

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278F2</Address>
      <Comment>(0)
mText("")
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1278FE</Address>
      <Comment>aBodyReanim-&gt;GetCurrentTransform(aTrackIndex, &amp;aTransform);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127903</Address>
      <Comment>mPosY
回忆一下edi是僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127906</Address>
      <Comment>获取僵尸图像图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127909</Address>
      <Comment>aTransform.mTransY
mPosY + aTranform.mTransY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12790D</Address>
      <Comment>僵尸所在行数
ebp不再指向栈基址

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127910</Address>
      <Comment>僵尸图层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127914</Address>
      <Comment>(6.00)
mPosY + aTransform.mTransY + 6.0f;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12791A</Address>
      <Comment>float aOriginY = mPosY + aTransform.mTransY + 6.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127922</Address>
      <Comment>利用 SSE 相关指令将 st(0) 的浮点数强制转化为整数存储在 eax 中。
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127927</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12792A</Address>
      <Comment>mPosX + aTransform.mTransX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12792E</Address>
      <Comment>综合之前的操作,这是把[esp+14]转化为了整型
注意[esp+14]就是aOriginY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127932</Address>
      <Comment>(9.00)
mPosX + aTransform.mTransX - 9.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127938</Address>
      <Comment>float aOriginX = mPosX + aTransform.mTransX - 9.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127940</Address>
      <Comment>同上,强转aOriginX为整型

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127945</Address>
      <Comment>先获取mBoard,然后下一行计算偏移
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127948</Address>
      <Comment>获取子弹数组(严格来讲不是数组类型,但是是一个线性表)
属性DataArray&lt;Projectile&gt; mProjectiles
esi = DataArray&lt;Projectile&gt;* this

函数表有误,不是esi,应该是edi

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12794E</Address>
      <Comment>aOriginX转化完成
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127952</Address>
      <Comment>此处又进行了函数展开的编译优化
Projectile* aProjectile = mProjectiles.DataArrayAlloc();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127957</Address>
      <Comment>(int)aOriginY
edi = int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12795B</Address>
      <Comment>新分配的子弹指针存储在esi中
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12795D</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127960</Address>
      <Comment>eax = int theX /*(int)aOrginX*/

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127964</Address>
      <Comment>ecx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127966</Address>
      <Comment>Board::PixelToGridX(edi = int theY, eax = int theX, ecx = Board* this)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12796B</Address>
      <Comment>这里展开了很多层
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12796D</Address>
      <Comment>这个地方一般不会发生跳转

展开前函数定义:
int Board::PixelToGridXKeepOnBoard(int theX/*(int)aOriginX*/, int theY/*(int)aOriginY*/)
{
	int aGridX = PixelToGridX(theX, theY);
	return max(aGridX, 0);
}

调用结束后,会想办法将结果保存至edi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12796F</Address>
      <Comment>eax = int theX/*(int)aOriginX*/

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127973</Address>
      <Comment>ecx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12797A</Address>
      <Comment>保存结果至edi
为什么调用了两次?代码混淆?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127980</Address>
      <Comment>现在edi就是刚刚Board::PixelToGridX的返回结果了
加载横坐标(int)aOriginX入浮点数栈
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127984</Address>
      <Comment>eax = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127986</Address>
      <Comment>ecx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127988</Address>
      <Comment>子弹类型设置为僵尸豌豆
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12798F</Address>
      <Comment>这里把[esp+10]又转化成了浮点数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127997</Address>
      <Comment>子弹-&gt;mPosX = aOriginX
严格的讲aOriginX被转整数然后又转回浮点数已经不同了,但是为了方便还是这么写
高级语言源码:mPosY = theY


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279A6</Address>
      <Comment>子弹-&gt;mPosY = aOriginY,原因同理
高级语言源码:mPosX = theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279AB</Address>
      <Comment>mPosZ = 0.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279AE</Address>
      <Comment>mVelX = 0.0f;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279B1</Address>
      <Comment>mVelY = 0.0f;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279B4</Address>
      <Comment>mVelZ = 0.0f;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279B7</Address>
      <Comment>mAccZ = 0.0f;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279BA</Address>
      <Comment>mBoard-&gt;GridToPixelY(aGridX, theRow)
ebx已经是mBoard指针了,所以没有进行专门的传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279BF</Address>
      <Comment>mShadowY的中间结果

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279C3</Address>
      <Comment>mShadowY的中间结果
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279C7</Address>
      <Comment>CE自动生成的注释是255,有问题,这是32位的按位或
mov eax,FFFFFFFF
解释为-1更合适
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279CA</Address>
      <Comment>见5279E7
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279CC</Address>
      <Comment>mHitTorchwoodGridX = -1;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279D5</Address>
      <Comment>mLastPortalX = -1;
参考源码中没有
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279DB</Address>
      <Comment>二维数组变址寻址
如果看不懂可以参照源代码:
mOnHighGround = mBoard-&gt;mGridSquareType[aGridX][theRow] == GridSquareType::GRIDSQUARE_HIGH_GROUND;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279DF</Address>
      <Comment>6*edi+ebp+90(十进制的90)
5A
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279E3</Address>
      <Comment>mShadowY = mBoard-&gt;GridToPixelY(aGridX, theRow) + 67.0f;
GridToPixelY已在刚刚解释过
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279E7</Address>
      <Comment>mMotionType = ProjectileMotion::MOTION_STRAIGHT;
这是一个默认值,具体运动方式需要手动设置
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279EE</Address>
      <Comment>子弹-&gt;mFrame = 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279F1</Address>
      <Comment>mShadowY被写入
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279F4</Address>
      <Comment>子弹-&gt;mNumFrames = 1;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1279FD</Address>
      <Comment>子弹-&gt;行数 = 僵尸-&gt;行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A00</Address>
      <Comment>mCobTargetX = 0.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A06</Address>
      <Comment>mDamageRangeFlags = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A09</Address>
      <Comment>mDead = false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A0C</Address>
      <Comment>mAttachmentID = AttachmentID::ATTACHMENTID_NULL;
子弹附件动画编号
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A0F</Address>
      <Comment>mCobTargetRow = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A15</Address>
      <Comment>mTargetZombieID = ZombieID::ZOMBIEID_NULL;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A1B</Address>
      <Comment>回忆一下,ebx是mBoard
[ebx+168+sizeof(int)*(6*edi+ebp)]
获取格子类型,并与04（即:高地）作比较
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A22</Address>
      <Comment>写入属性mOnHighGround
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A25</Address>
      <Comment>获取场景类型
此为函数展开:
bool Board::StageHasRoof()
{
	return (mBackground == BackgroundType::BACKGROUND_5_ROOF || mBackground == BackgroundType::BACKGROUND_6_BOSS);
}
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A2B</Address>
      <Comment>BackgroundType::BACKGROUND_5_ROOF
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A30</Address>
      <Comment>BackgroundType::BACKGROUND_6_BOSS
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A35</Address>
      <Comment>横坐标
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A39</Address>
      <Comment>(480.00)
判断子弹横坐标处于屋顶中线左侧还是右侧

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A4E</Address>
      <Comment>mShadowY -= 12.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A53</Address>
      <Comment>子弹不满足屋顶中线条件的处理逻辑
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A55</Address>
      <Comment>重新恢复edx为子弹图层
因为call 41DF60改变过它
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A59</Address>
      <Comment>mRotation = 0.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A61</Address>
      <Comment>mRotationSpeed = 0.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A64</Address>
      <Comment>横坐标
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A68</Address>
      <Comment>mRenderOrder = theRenderOrder;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A6B</Address>
      <Comment>mProjectileAge = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A6E</Address>
      <Comment>mClickBackoffCounter = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A71</Address>
      <Comment>mWidth = 40;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A74</Address>
      <Comment>mHeight = 40;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A77</Address>
      <Comment>mAnimTicksPerFrame = 0;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A7A</Address>
      <Comment>mAnimCounter = 0;
编译器很聪明,直接跳过了函数展开的一堆分支判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A7D</Address>
      <Comment>浮点数强转整数指令:
eax = (int)st(0)
此时浮点寄存器栈顶为横坐标
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A82</Address>
      <Comment>mPosY压入浮点寄存器栈传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A86</Address>
      <Comment>mX = (int)mPosX;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A8E</Address>
      <Comment>mY = (int)mPosY;
这条指令之后,AddProjectile函数展开完毕
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+127A91</Address>
      <Comment>aProjectile-&gt;mMotionType = ProjectileMotion::MOTION_BACKWARDS;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128313</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128316</Address>
      <Comment>获取僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12831B</Address>
      <Comment>mZombiePhase == ZombiePhase::PHASE_DIGGER_TUNNELING
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12832A</Address>
      <Comment>if (mPosX &lt; 10.0f)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12833E</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12833F</Address>
      <Comment>mAltitude = -120.0f;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128345</Address>
      <Comment>mZombiePhase = ZombiePhase::PHASE_DIGGER_RISING;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128352</Address>
      <Comment>mPhaseCounter = 130;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128359</Address>
      <Comment>float theAnimRate
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12835C</Address>
      <Comment>int theBlendTime
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12835E</Address>
      <Comment>ReanimLoopType theLoopType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128360</Address>
      <Comment>/*%s*/
const char* theTrackName
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128365</Address>
      <Comment>edi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12836C</Address>
      <Comment>mApp-&gt;PlayFoley日常展开
函数指令就是被这堆东西搞得又臭又长的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12839A</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12839B</Address>
      <Comment>float range
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283A7</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283AE</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283AF</Address>
      <Comment>/*FoleyType::FOLEY_DIRT_RISE*/
eax = FoleyType theFoleyType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283B4</Address>
      <Comment>float thePitch
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283B7</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283B9</Address>
      <Comment>太麻烦了,以后的关于mApp-&gt;PlayFoley的函数展开均不做详细注释
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+1283C0</Address>
      <Comment>mApp-&gt;PlayFoley(FoleyType::FOLEY_WAKEUP);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128416</Address>
      <Comment>ParticleEffect theParticleEffect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128418</Address>
      <Comment>eax = AttachmentID&amp; theAttachmentID
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12841E</Address>
      <Comment>AttachmentDetachCrossFadeParticleType(mAttachmentID, ParticleEffect::PARTICLE_DIGGER_TUNNEL, nullptr);
与参考源码仍然有出入
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128423</Address>
      <Comment>_cdecl
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128426</Address>
      <Comment>Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128427</Address>
      <Comment>StopZombieSound();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12842C</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12842F</Address>
      <Comment>%s
mPosY+118.0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128435</Address>
      <Comment>mRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128438</Address>
      <Comment>mApp
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12843A</Address>
      <Comment>mApp-&gt;mEffectSystem
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128440</Address>
      <Comment>mApp-&gt;mEffectSystem-&gt;mParticleHolder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12844A</Address>
      <Comment>/*ParticleEffect::PARTICLE_DIGGER_RISE*/
ParticleEffect theParticleEffect

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12844C</Address>
      <Comment> mRenderOrder + 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12844F</Address>
      <Comment>int theRenderOrder
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128450</Address>
      <Comment>占位
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128453</Address>
      <Comment>float theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128457</Address>
      <Comment>mPosX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12845A</Address>
      <Comment>%s
mPosX + 60.0f
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128460</Address>
      <Comment>
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128468</Address>
      <Comment>float theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12846B</Address>
      <Comment>mApp-&gt;AddTodParticle(mPosX + 60.0f, mPosY + 118.0f, mRenderOrder + 1, ParticleEffect::PARTICLE_DIGGER_RISE);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128470</Address>
      <Comment>mPosY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128473</Address>
      <Comment>mRenderLayer
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+128476</Address>
      <Comment>%s
mPosY+97.0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12847C</Address>
      <Comment>mRenderLayer+1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AD5F</Address>
      <Comment>UpdateZombieWalking()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AD78</Address>
      <Comment>CheckSquish()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AD7D</Address>
      <Comment>检查僵尸是否处于被吹走状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AE63</Address>
      <Comment>栈对齐
推测之后会使用栈底寻址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AE66</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AE69</Address>
      <Comment>获取僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12AE6B</Address>
      <Comment>mZombieAge++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E564</Address>
      <Comment> if (mZombiePhase == ZombiePhase::PHASE_DIGGER_TUNNELING)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E569</Address>
      <Comment>thePlant-&gt;mSeedType == SeedType::SEED_POTATOMINE
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E56E</Address>
      <Comment>thePlant-&gt;mState == PlantState::STATE_NOTREADY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E572</Address>
      <Comment>若刚刚的条件成立则return true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E920</Address>
      <Comment>本函数中,edi是僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E923</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E926</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E928</Address>
      <Comment>esi = Plant*&amp; thePlant
这是一个局部变量地址
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E92C</Address>
      <Comment>Plant* aPlant = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E934</Address>
      <Comment>mBoard-&gt;IteratePlants(aPlant)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E939</Address>
      <Comment>while (mBoard-&gt;IteratePlants(aPlant))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E93B</Address>
      <Comment>若找不到植物了,就跳出循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E93D</Address>
      <Comment>ZombieAttackType::ATTACKTYPE_DRIVE_OVER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E942</Address>
      <Comment>获取植物指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E946</Address>
      <Comment>精准堆栈,theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E94A</Address>
      <Comment>if (aPlant-&gt;mRow == theY...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E94F</Address>
      <Comment>精准堆栈,theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E953</Address>
      <Comment>if (...aPlant-&gt;mPlantCol == theX)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E956</Address>
      <Comment>条件跳转至下一轮循环
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E958</Address>
      <Comment>[esp+1C]是theAttackType
theAttackType == ZombieAttackType::ATTACKTYPE_DRIVE_OVER

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E95E</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E961</Address>
      <Comment>地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E966</Address>
      <Comment>钢地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E96B</Address>
      <Comment>再次判断植物是不是钢地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E971</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E974</Address>
      <Comment>mBoard-&gt;mPlantsEaten++;
记得ebx已经是1了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E97A</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E97B</Address>
      <Comment>aPlant-&gt;Squish();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E980</Address>
      <Comment>edx = Board* this
下一轮循环的判断
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E983</Address>
      <Comment>esi = Plant*&amp; thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E987</Address>
      <Comment>mBoard-&gt;IteratePlants(aPlant)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12E990</Address>
      <Comment>恢复易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDB0</Address>
      <Comment>教科书级别的指令
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDB3</Address>
      <Comment>栈对齐
类似于一次push
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDB6</Address>
      <Comment>局部变量存储区
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDB9</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDBA</Address>
      <Comment>精准堆栈,僵尸指针
ebx = Zombie* this
注意是通过ebp栈底进行的寻址,相对位置不会受push影响
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDBD</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDBF</Address>
      <Comment>edi = _Out_ Rect&amp;&amp; aZombieAttackRect
注意前面两次push是保存易变寄存器,不是函数调用

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDC3</Address>
      <Comment>GetZombieAttackRect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDC8</Address>
      <Comment>僵尸矩形mWidth保存至ebx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDCC</Address>
      <Comment>僵尸矩形mX保存至edi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDD0</Address>
      <Comment>Plant* aPlant = nullptr;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDDA</Address>
      <Comment>废话代码
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDE0</Address>
      <Comment>再次精准堆栈
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDE3</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDE6</Address>
      <Comment>esi = Plant*&amp; thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDEA</Address>
      <Comment>mBoard-&gt;IteratePlants(aPlant)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDEF</Address>
      <Comment>while (mBoard-&gt;IteratePlants(aPlant))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDF7</Address>
      <Comment>第三次精准堆栈
ecx为僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDFA</Address>
      <Comment>edx为僵尸行数

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EDFD</Address>
      <Comment>esi为植物指针

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE01</Address>
      <Comment>aPlant-&gt;mRow == mRow
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE04</Address>
      <Comment>if (aPlant-&gt;mRow == mRow)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE06</Address>
      <Comment>eax = _Out_ Rect&amp;&amp; aInjuryRect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE0A</Address>
      <Comment>ecx = Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE0C</Address>
      <Comment>GetPlantRect
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE11</Address>
      <Comment>获取植物矩形的mX,存储在ecx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE19</Address>
      <Comment>植物矩形mWidth,存储在edx
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE1D</Address>
      <Comment>僵尸矩形最右边
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE20</Address>
      <Comment>植物矩形最右边
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE43</Address>
      <Comment>逻辑真复杂...eax是植物与僵尸矩形的重叠部分
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE46</Address>
      <Comment>if (GetRectOverlap(aAttackRect, aPlantRect) &gt;= 20...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE48</Address>
      <Comment>第四次精准堆栈
ecx = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE4B</Address>
      <Comment>ZombieAttackType theAttackType
/*ATTACKTYPE_DRIVE_OVER*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE4D</Address>
      <Comment>Plant* thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE4E</Address>
      <Comment>CanTargetPlant(aPlant, ATTACKTYPE_DRIVE_OVER)
与参考源码有出入
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE55</Address>
      <Comment>if (...CanTargetPlant(aPlant, ATTACKTYPE_DRIVE_OVER))
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE57</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE5A</Address>
      <Comment>地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE5F</Address>
      <Comment>钢地刺
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE68</Address>
      <Comment>植物行数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE6B</Address>
      <Comment>植物列数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE6E</Address>
      <Comment>edi = Zombie* this
第五次精准堆栈..
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE71</Address>
      <Comment>ZombieAttackType theAttackType
/*ZombieAttackType::ATTACKTYPE_DRIVE_OVER*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE73</Address>
      <Comment>int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE74</Address>
      <Comment>int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE75</Address>
      <Comment>SquishAllInSquare(aPlant-&gt;mPlantCol, aPlant-&gt;mRow, ZombieAttackType::ATTACKTYPE_DRIVE_OVER);

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE7A</Address>
      <Comment>edi已经是僵尸指针了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE7C</Address>
      <Comment>循环体结束
第六次
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE81</Address>
      <Comment>mApp-&gt;IsIZombieLevel()被展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE8A</Address>
      <Comment>获取游戏模式
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE90</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE95</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE9A</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_3
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EE9F</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_4
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEA4</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_5
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEA9</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_6
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEAE</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_7
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEB3</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_8
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEB8</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_9
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEBD</Address>
      <Comment>GameMode::GAMEMODE_PUZZLE_I_ZOMBIE_ENDLESS
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEC2</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEC5</Address>
      <Comment>mBoard-&gt;mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EECB</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EECC</Address>
      <Comment>eax = Zombie* theZombie
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EECE</Address>
      <Comment>Challenge aBrain = mBoard-&gt;mChallenge-&gt;IZombieGetBrainTarget(this)
this代表Zombie而非Challenge

eax = Griditem* theBrain
该函数返回值也是"call 42BA30"的实参


</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EED3</Address>
      <Comment>if (aBrain)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EED7</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEDA</Address>
      <Comment>获取mBoard-&gt;mChallenge

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEE0</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEE1</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;IZombieSquishBrain(aBrain);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12EEE6</Address>
      <Comment>恢复易变寄存器加返回
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12F637</Address>
      <Comment>无须断点
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB55</Address>
      <Comment>前面是一些神奇的指令
似乎和操作系统有关,但是我现在还没有学操作系统,就跳过了
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB58</Address>
      <Comment>易变寄存器
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB5A</Address>
      <Comment>获取僵尸指针
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB5E</Address>
      <Comment>if (mZombiePhase == ZombiePhase::PHASE_DANCER_DANCING_IN)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB62</Address>
      <Comment>这仍然是易变寄存器,不是传参
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB64</Address>
      <Comment>ecx是被吃的植物指针,现在j交给esi
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB68</Address>
      <Comment>mPhaseCounter = 1;
舞王滑步时不会吃植物,但是如果碰到植物就会停止滑步
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB6F</Address>
      <Comment>又是操作系统的并发并行...
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB84</Address>
      <Comment>if (mYuckyFace)
被大蒜熏晕的时候不会吃植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB91</Address>
      <Comment>edi = int theGridY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB94</Address>
      <Comment>ebx = int theGridX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB97</Address>
      <Comment>edx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB9A</Address>
      <Comment>GridItemType theGridItemType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FB9C</Address>
      <Comment>mBoard-&gt;GetLadderAt(thePlant-&gt;mPlantCol, thePlant-&gt;mRow)
函数展开
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBA1</Address>
      <Comment>if (mBoard-&gt;GetLadderAt(thePlant-&gt;mPlantCol, thePlant-&gt;mRow)...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBA5</Address>
      <Comment>mZombieType != ZombieType::ZOMBIE_DIGGER
矿工无视梯子
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBAB</Address>
      <Comment>edi = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBB2</Address>
      <Comment>mZombieHeight == ZombieHeight::HEIGHT_ZOMBIE_NORMAL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBB6</Address>
      <Comment>if (mZombieHeight == ZombieHeight::HEIGHT_ZOMBIE_NORMAL...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBBC</Address>
      <Comment>mUseLadderCol
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBBF</Address>
      <Comment>mUseLadderCol != thePlant-&gt;mPlantCol
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBC2</Address>
      <Comment>if (...mUseLadderCol != thePlant-&gt;mPlantCol)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBC8</Address>
      <Comment>mZombieHeight = ZombieHeight::HEIGHT_UP_LADDER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBD2</Address>
      <Comment>mUseLadderCol = thePlant-&gt;mPlantCol
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBD5</Address>
      <Comment>操作系统
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBEA</Address>
      <Comment>eax = Zombie* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBEC</Address>
      <Comment>StartEating();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBF1</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBF4</Address>
      <Comment>辣椒
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBF9</Address>
      <Comment>樱桃
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FBFE</Address>
      <Comment>核弹
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC03</Address>
      <Comment>寒冰菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC08</Address>
      <Comment>魅惑菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC0D</Address>
      <Comment>植物状态
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC10</Address>
      <Comment>花盆种下(花盆种下后有一段无敌时间)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC15</Address>
      <Comment>莲叶种下(同上)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC1A</Address>
      <Comment>倭瓜发现僵尸
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC1F</Address>
      <Comment>倭瓜过渡
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC24</Address>
      <Comment>if (!thePlant-&gt;mIsAsleep)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC2B</Address>
      <Comment>如果植物没有睡着,就不能吃刚刚那些植物
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC31</Address>
      <Comment>是地雷吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC36</Address>
      <Comment>if (...thePlant-&gt;mState != PlantState::STATE_NOTREADY)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC40</Address>
      <Comment>triggered=false;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC42</Address>
      <Comment>if (thePlant-&gt;mSeedType == SeedType::SEED_BLOVER)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC45</Address>
      <Comment>52FCA8要用
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC4C</Address>
      <Comment>triggered = true;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC4E</Address>
      <Comment>if (...thePlant-&gt;mSeedType == SeedType::SEED_ICESHROOM...)
寒冰菇
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC53</Address>
      <Comment>寒冰菇有没有在睡觉?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC5C</Address>
      <Comment>if (triggered)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC60</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC61</Address>
      <Comment>thePlant-&gt;DoSpecial();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC66</Address>
      <Comment>操作系统
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC7B</Address>
      <Comment>mChilledCounter &gt; 0
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC84</Address>
      <Comment>mZombieAge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC87</Address>
      <Comment>mZombieAge % 2 == 1
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC96</Address>
      <Comment>条件跳转到返回
逆天思路:僵尸减速状态下啃食速度/=2原来是这样实现的
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC9C</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FC9F</Address>
      <Comment>mApp-&gt;IsIZombieLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCA4</Address>
      <Comment>if (mApp-&gt;IsIZombieLevel())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCA8</Address>
      <Comment>植物类型是向日葵吗?
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCAC</Address>
      <Comment>thePlant-&gt;mPlantHealth
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCC0</Address>
      <Comment>(thePlant-&gt;mPlantHealth - DAMAGE_PER_EAT)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCD4</Address>
      <Comment>刚刚又是复杂的除法算法
int aStageBeforeChew = thePlant-&gt;mPlantHealth / 40;
int aStageAfterChew = (thePlant-&gt;mPlantHealth - DAMAGE_PER_EAT) / 40;
if (aStageAfterChew &lt; aStageBeforeChew...)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCD8</Address>
      <Comment>if (...thePlant-&gt;mPlantHealth - DAMAGE_PER_EAT &lt;= 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCDC</Address>
      <Comment>mY

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCDF</Address>
      <Comment>mX

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCE2</Address>
      <Comment>/*CoinMotion::COIN_MOTION_FROM_PLANT*/
CoinMotion theCoinMotion

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCE4</Address>
      <Comment>/*CoinType::COIN_SUN*/
CoinType theCoinType
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCE6</Address>
      <Comment>int theY
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCE7</Address>
      <Comment>int theX
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCE8</Address>
      <Comment>ecx = Board* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCEB</Address>
      <Comment>mBoard-&gt;AddCoin(thePlant-&gt;mX, thePlant-&gt;mY, CoinType::COIN_SUN, CoinMotion::COIN_MOTION_FROM_PLANT);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCF0</Address>
      <Comment>thePlant-&gt;mPlantHealth -= DAMAGE_PER_EAT;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCF4</Address>
      <Comment>获取植物血量
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FCF7</Address>
      <Comment>thePlant-&gt;mRecentlyEatenCountdown = 50;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD01</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD04</Address>
      <Comment>mApp-&gt;IsIZombieLevel()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD09</Address>
      <Comment>if (mApp-&gt;IsIZombieLevel())
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD0D</Address>
      <Comment>mJustGotShotCounter &lt; -500
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD16</Address>
      <Comment>植物类型
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD19</Address>
      <Comment>thePlant-&gt;mSeedType == SeedType::SEED_WALLNUT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD1E</Address>
      <Comment>thePlant-&gt;mSeedType == SeedType::SEED_TALLNUT
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD23</Address>
      <Comment>thePlant-&gt;mSeedType == SeedType::SEED_PUMPKINSHELL
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD2B</Address>
      <Comment>thePlant-&gt;mPlantHealth -= DAMAGE_PER_EAT;

</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD2E</Address>
      <Comment>if (thePlant-&gt;mPlantHealth &lt;= 0)
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD38</Address>
      <Comment>ecx = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD3D</Address>
      <Comment>%s
/*SOUND_GULP*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD48</Address>
      <Comment>int theSoundNum
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD49</Address>
      <Comment>4560C0
虚函数
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD4E</Address>
      <Comment>mBoard-&gt;mPlantsEaten++;
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD54</Address>
      <Comment>Plant* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD55</Address>
      <Comment>thePlant-&gt;Die();
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD5A</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD5D</Address>
      <Comment>mBoard-&gt;mChallenge
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD63</Address>
      <Comment>Challenge* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD64</Address>
      <Comment>ecx = Plant* thePlant
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD66</Address>
      <Comment>mBoard-&gt;mChallenge-&gt;ZombieAtePlant(this, thePlant);
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD6B</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD6E</Address>
      <Comment>mLevel
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD74</Address>
      <Comment>mBoard-&gt;mLevel &gt;= 2
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD79</Address>
      <Comment>mBoard-&gt;mLevel &lt;= 4
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD7E</Address>
      <Comment>eax = LawnApp* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD81</Address>
      <Comment>mApp-&gt;IsFirstTimeAdventureMode()
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD8A</Address>
      <Comment>thePlant-&gt;mPlantCol &gt; 4
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD90</Address>
      <Comment>mBoard-&gt;mPlants.mSize &lt; 15
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD99</Address>
      <Comment>thePlant-&gt;mSeedType == SeedType::SEED_PEASHOOTER
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FD9F</Address>
      <Comment>/*%s/
const char* _Ptr
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDA4</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDB5</Address>
      <Comment>mBoard
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDB8</Address>
      <Comment>55A8+39
if (mHelpDisplayed[theHelpIndex])
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDC1</Address>
      <Comment>esi = MessageWidget* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDC7</Address>
      <Comment>/*MessageStyle::MESSAGE_STYLE_HINT_TALL_FAST*/
ecx = MessageStyle theMessageStyle
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDCC</Address>
      <Comment>edx = const std::string&amp; theNewLabel
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDD0</Address>
      <Comment>mHelpDisplayed[theHelpIndex] = true;
注意之前已经把ebx设置为1,就地取材
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDDB</Address>
      <Comment>mHelpIndex = theHelpIndex;
/*AdviceType::ADVICE_PEASHOOTER_DIED*/
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDE5</Address>
      <Comment>ecx = std::string* this
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+12FDEE</Address>
      <Comment>操作系统
</Comment>
    </DisassemblerComment>
    <DisassemblerComment>
      <Address>"popcapgame1.exe"+13450C</Address>
      <Comment>处于Zombie::DrawShadow(Graphics* g, edi = Zombie* this)函数体中

</Comment>
    </DisassemblerComment>
  </DisassemblerComments>
</CheatTable>
